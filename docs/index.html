<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>GraphBLAS C++ API Specification v1.0</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <style>
  body {
    max-width: 48em;
  }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">GraphBLAS C++ API Specification v1.0</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#intro" id="toc-intro">Intro</a>
<ul>
<li><a href="#data-structures" id="toc-data-structures">Data
Structures</a></li>
<li><a href="#concepts" id="toc-concepts">Concepts</a></li>
</ul></li>
<li><a href="#basic-concepts" id="toc-basic-concepts">Basic Concepts</a>
<ul>
<li><a href="#graphblas-containers"
id="toc-graphblas-containers">GraphBLAS Containers</a></li>
</ul></li>
<li><a href="#grbmatrix" id="toc-grbmatrix"><code>grb::matrix</code></a>
<ul>
<li><a href="#template-parameters" id="toc-template-parameters">Template
Parameters</a></li>
<li><a href="#member-types" id="toc-member-types">Member Types</a></li>
<li><a href="#methods" id="toc-methods">Methods</a></li>
<li><a href="#grbmatrixmatrix"
id="toc-grbmatrixmatrix"><code>grb::matrix::matrix</code></a></li>
<li><a href="#grbmatrixmatrix-1"
id="toc-grbmatrixmatrix-1"><code>grb::matrix::~matrix</code></a></li>
<li><a href="#grbmatrixoperator"
id="toc-grbmatrixoperator"><code>grb::matrix::operator=</code></a></li>
<li><a href="#grbmatrixsize"
id="toc-grbmatrixsize"><code>grb::matrix::size</code></a></li>
<li><a href="#grbmatrixmax_size"
id="toc-grbmatrixmax_size"><code>grb::matrix::max_size</code></a></li>
<li><a href="#grbmatrixempty"
id="toc-grbmatrixempty"><code>grb::matrix::empty</code></a></li>
<li><a href="#grbmatrixshape"
id="toc-grbmatrixshape"><code>grb::matrix::shape</code></a></li>
<li><a href="#grbmatrixbegin-and-grbmatrixcbegin"
id="toc-grbmatrixbegin-and-grbmatrixcbegin"><code>grb::matrix::begin</code>
and <code>grb::matrix::cbegin</code></a></li>
<li><a href="#grbmatrixend-and-grbmatrixcend"
id="toc-grbmatrixend-and-grbmatrixcend"><code>grb::matrix::end</code>
and <code>grb::matrix::cend</code></a></li>
<li><a href="#grbmatrixreshape"
id="toc-grbmatrixreshape"><code>grb::matrix::reshape</code></a></li>
<li><a href="#grbmatrixclear"
id="toc-grbmatrixclear"><code>grb::matrix::clear</code></a></li>
<li><a href="#grbmatrixinsert"
id="toc-grbmatrixinsert"><code>grb::matrix::insert</code></a></li>
<li><a href="#grbmatrixinsert_or_assign"
id="toc-grbmatrixinsert_or_assign"><code>grb::matrix::insert_or_assign</code></a></li>
<li><a href="#grbmatrixerase"
id="toc-grbmatrixerase"><code>grb::matrix::erase</code></a></li>
<li><a href="#grbmatrixfind"
id="toc-grbmatrixfind"><code>grb::matrix::find</code></a></li>
<li><a href="#grbmatrixoperator-1"
id="toc-grbmatrixoperator-1"><code>grb::matrix::operator[]</code></a></li>
<li><a href="#grbmatrixat"
id="toc-grbmatrixat"><code>grb::matrix::at</code></a></li>
</ul></li>
<li><a href="#grbvector" id="toc-grbvector"><code>grb::vector</code></a>
<ul>
<li><a href="#template-parameters-1"
id="toc-template-parameters-1">Template Parameters</a></li>
<li><a href="#member-types-1" id="toc-member-types-1">Member
Types</a></li>
<li><a href="#methods-1" id="toc-methods-1">Methods</a></li>
<li><a href="#grbvectorvector"
id="toc-grbvectorvector"><code>grb::vector::vector</code></a></li>
<li><a href="#grbvectorsize"
id="toc-grbvectorsize"><code>grb::vector::size</code></a></li>
<li><a href="#grbvectormax_size"
id="toc-grbvectormax_size"><code>grb::vector::max_size</code></a></li>
<li><a href="#grbvectorempty"
id="toc-grbvectorempty"><code>grb::vector::empty</code></a></li>
<li><a href="#grbvectorshape"
id="toc-grbvectorshape"><code>grb::vector::shape</code></a></li>
<li><a href="#grbvectorbegin-and-grbvectorcbegin"
id="toc-grbvectorbegin-and-grbvectorcbegin"><code>grb::vector::begin</code>
and <code>grb::vector::cbegin</code></a></li>
<li><a href="#grbvectorend-and-grbvectorcend"
id="toc-grbvectorend-and-grbvectorcend"><code>grb::vector::end</code>
and <code>grb::vector::cend</code></a></li>
<li><a href="#grbvectorreshape"
id="toc-grbvectorreshape"><code>grb::vector::reshape</code></a></li>
<li><a href="#grbvectorclear"
id="toc-grbvectorclear"><code>grb::vector::clear</code></a></li>
<li><a href="#grbvectorinsert"
id="toc-grbvectorinsert"><code>grb::vector::insert</code></a></li>
<li><a href="#grbvectorinsert_or_assign"
id="toc-grbvectorinsert_or_assign"><code>grb::vector::insert_or_assign</code></a></li>
<li><a href="#grbvectorerase"
id="toc-grbvectorerase"><code>grb::vector::erase</code></a></li>
<li><a href="#grbvectorfind"
id="toc-grbvectorfind"><code>grb::vector::find</code></a></li>
<li><a href="#grbvectoroperator"
id="toc-grbvectoroperator"><code>grb::vector::operator[]</code></a></li>
<li><a href="#grbvectorat"
id="toc-grbvectorat"><code>grb::vector::at</code></a></li>
</ul></li>
<li><a href="#grbindex" id="toc-grbindex"><code>grb::index</code></a>
<ul>
<li><a href="#template-parameters-2"
id="toc-template-parameters-2">Template Parameters</a></li>
<li><a href="#member-types-2" id="toc-member-types-2">Member
Types</a></li>
<li><a href="#member-objects" id="toc-member-objects">Member
Objects</a></li>
<li><a href="#methods-2" id="toc-methods-2">Methods</a></li>
</ul></li>
<li><a href="#sparse-storage-format-hints"
id="toc-sparse-storage-format-hints">Sparse Storage Format Hints</a>
<ul>
<li><a href="#grbsparse"
id="toc-grbsparse"><code>grb::sparse</code></a></li>
<li><a href="#grbdense"
id="toc-grbdense"><code>grb::dense</code></a></li>
<li><a href="#grbrow" id="toc-grbrow"><code>grb::row</code></a></li>
<li><a href="#grbcolumn"
id="toc-grbcolumn"><code>grb::column</code></a></li>
<li><a href="#grbcompose"
id="toc-grbcompose"><code>grb::compose</code></a></li>
</ul></li>
<li><a href="#views" id="toc-views">Views</a>
<ul>
<li><a href="#grbviewstranspose"
id="toc-grbviewstranspose">grb::views::transpose</a></li>
<li><a href="#grbviewstransform"
id="toc-grbviewstransform">grb::views::transform</a></li>
<li><a href="#grbstructure"
id="toc-grbstructure">grb::structure</a></li>
<li><a href="#grbfilter" id="toc-grbfilter">grb::filter</a></li>
<li><a href="#grbcomplement"
id="toc-grbcomplement">grb::complement</a></li>
<li><a href="#grbmask" id="toc-grbmask">grb::mask</a></li>
<li><a href="#grbsubmatrix_view"
id="toc-grbsubmatrix_view">grb::submatrix_view</a></li>
</ul></li>
<li><a href="#pre-defined-operators"
id="toc-pre-defined-operators">Pre-Defined Operators</a>
<ul>
<li><a href="#binary-operator-template-parameters"
id="toc-binary-operator-template-parameters">Binary Operator Template
Parameters</a></li>
<li><a href="#grbplus" id="toc-grbplus"><code>grb::plus</code></a></li>
<li><a href="#grbmultiplies"
id="toc-grbmultiplies"><code>grb::multiplies</code></a></li>
<li><a href="#grbminus"
id="toc-grbminus"><code>grb::minus</code></a></li>
<li><a href="#grbdivides"
id="toc-grbdivides"><code>grb::divides</code></a></li>
<li><a href="#grbmax" id="toc-grbmax"><code>grb::max</code></a></li>
<li><a href="#grbmin" id="toc-grbmin"><code>grb::min</code></a></li>
</ul></li>
<li><a href="#utilities" id="toc-utilities">Utilities</a>
<ul>
<li><a href="#grbget" id="toc-grbget"><code>grb::get</code></a></li>
<li><a href="#grbsize" id="toc-grbsize"><code>grb::size</code></a></li>
<li><a href="#grbshape"
id="toc-grbshape"><code>grb::shape</code></a></li>
<li><a href="#grbfind" id="toc-grbfind"><code>grb::find</code></a></li>
<li><a href="#grbinsert"
id="toc-grbinsert"><code>grb::insert</code></a></li>
<li><a href="#scalar_result_type_t"
id="toc-scalar_result_type_t"><code>scalar_result_type_t</code></a></li>
<li><a href="#multiply_result_t"
id="toc-multiply_result_t"><code>multiply_result_t</code></a></li>
<li><a href="#combine_result_t"
id="toc-combine_result_t"><code>combine_result_t</code></a></li>
<li><a href="#ewise_union_result_t"
id="toc-ewise_union_result_t"><code>ewise_union_result_t</code></a></li>
<li><a href="#ewise_intersection_result_t"
id="toc-ewise_intersection_result_t"><code>ewise_intersection_result_t</code></a></li>
<li><a href="#read_matrix"
id="toc-read_matrix"><code>read_matrix</code></a></li>
<li><a href="#template-parameters-9"
id="toc-template-parameters-9">Template Parameters</a></li>
</ul></li>
<li><a href="#concepts-1" id="toc-concepts-1">Concepts</a>
<ul>
<li><a href="#binary-operator" id="toc-binary-operator">Binary
Operator</a></li>
<li><a href="#monoid" id="toc-monoid">Monoid</a></li>
<li><a href="#tuple-like-type" id="toc-tuple-like-type">Tuple-Like
Type</a></li>
<li><a href="#matrix-entry" id="toc-matrix-entry">Matrix Entry</a></li>
<li><a href="#mutable-matrix-entry"
id="toc-mutable-matrix-entry">Mutable Matrix Entry</a></li>
<li><a href="#matrix-range" id="toc-matrix-range">Matrix Range</a></li>
<li><a href="#mutable-matrix-range"
id="toc-mutable-matrix-range">Mutable Matrix Range</a></li>
<li><a href="#mask-matrix-range" id="toc-mask-matrix-range">Mask Matrix
Range</a></li>
<li><a href="#vector-entry" id="toc-vector-entry">Vector Entry</a></li>
<li><a href="#mutable-vector-entry"
id="toc-mutable-vector-entry">Mutable Vector Entry</a></li>
<li><a href="#vector-range" id="toc-vector-range">Vector Range</a></li>
<li><a href="#mutable-vector-range"
id="toc-mutable-vector-range">Mutable Vector Range</a></li>
<li><a href="#mask-vector-range" id="toc-mask-vector-range">Mask Vector
Range</a></li>
</ul></li>
<li><a href="#type-traits" id="toc-type-traits">Type Traits</a>
<ul>
<li><a href="#grbmonoid_traits"
id="toc-grbmonoid_traits"><code>grb::monoid_traits</code></a></li>
<li><a href="#template-parameters-10"
id="toc-template-parameters-10">Template Parameters</a></li>
</ul></li>
<li><a href="#algorithms" id="toc-algorithms">Algorithms</a>
<ul>
<li><a href="#execution-policy" id="toc-execution-policy">Execution
Policy</a></li>
<li><a href="#exceptions-and-error-handling"
id="toc-exceptions-and-error-handling">Exceptions and Error
Handling</a></li>
<li><a href="#multiply" id="toc-multiply">Multiply</a></li>
<li><a href="#ewise_union"
id="toc-ewise_union"><code>ewise_union</code></a></li>
<li><a href="#ewise_intersection"
id="toc-ewise_intersection"><code>ewise_intersection</code></a></li>
<li><a href="#assign" id="toc-assign"><code>assign</code></a></li>
</ul></li>
</ul>
</nav>
<hr />
<h1 id="intro">Intro</h1>
<p>The GraphBLAS standard defines a set of generalized matrix and vector
operations based on semiring algebraic structures. These operations can
be used to express a wide variety of graph algorithms. This
specification document defines the C++ programming interface for the
GraphBLAS standard, referred to as the . The GraphBLAS C++ API defines a
collection of data structures, algorithms, views, operators, and
concepts for implementing graph algorithms. These API components are
based around mathematical objects, such as matrices and vectors, and
operations, such as generalized matrix multiplication and element-wise
operations. The <a
href="https://github.com/GraphBLAS/graphblas-api-math">GraphBLAS Math
Specification</a> provides a complete specification of the mechanics of
these structures and operations, and provides a rigorous mathematical
definition of the operations and data structures provided in this
specification.</p>
<h2 id="data-structures">Data Structures</h2>
<p>This specification provides data structures for storing matrices and
vectors. These implement the matrix and vector range <a
href="#concepts">concepts</a> also defined in this specification.</p>
<h3 id="matrices">Matrices</h3>
<p>Matrices are two-dimensional collections of sparse values. Each
matrix has a defined number of rows and columns, which define its . In
addition, each matrix has a defined number of , which are indices inside
the bounds of the matrix which actually contain scalar values. A matrix
has a fixed , which is the type of the stored values, as well as an ,
which is the type of the indices.</p>
<p>GraphBLAS matrices are sparse, consist of a well-defined set of
stored values, and have no implicit zero value for empty indices. As
such, operations may not arbitrarily insert explicit zero values into
the matrix, but must produce an output with the exact set of values as
specified by the GraphBLAS Math Specification.</p>
<p>The GraphBLAS matrix data structure defined in this specification,
<code>grb::matrix</code>, provides mechanisms for creating,
manipulating, and iterating through GraphBLAS matrices. It also includes
a mechanism for influencing the storage format through compile-time
hints. GraphBLAS operations that accept matrices can be called with
other types so long as they fulfill the GraphBLAS matrix concepts.</p>
<h3 id="vectors">Vectors</h3>
<p>Vectors are one-dimensional collections of sparse values. Each vector
has a defined number of indices, which defines its shape. Similarly, it
has a defined number of stored stored values, which must lie at indices
within its shape. Its scalar values have a fixed scalar type, and it has
a fixed index type for storing indices. Vectors follow the same sparsity
rules as matrices, and similarly the GraphBLAS matrix concepts.</p>
<h2 id="concepts">Concepts</h2>
<p>The GraphBLAS C++ Specification defines matrix and vector concepts.
These define the interface that a type must support in order to be used
by GraphBLAS operations. The intention is that data structures defined
by other libraries may be used in GraphBLAS operations so long as they
define a small number of customization points that perform insert, find,
and iteration operations over the matrix or vector.</p>
<h3 id="version-conformance">Version Conformance</h3>
<p>A C++ GraphBLAS library should define the macro
<code>GRAPHBLAS_CPP_VERSION</code> to indicate its level of conformance
with the GraphBLAS C++ API. To indicate conformance with the GraphBLAS
0.1a draft specification, a library should provide the macro
<code>GRAPHBLAS_CPP_VERSION</code> with a value greater than or equal to
<code>202207L</code>.</p>
<h4 id="exposition-only">Exposition Only</h4>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define the `GRAPHBLAS_CPP_VERSION` macro to indicate</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// conformance to the GraphBLAS 0.1 Draft Specification.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define GRAPHBLAS_CPP_VERSION </span><span class="dv">202207</span><span class="bu">L</span></span></code></pre></div>
<h1 id="basic-concepts">Basic Concepts</h1>
<p>GraphBLAS defines a collection of objects, functions, and concepts to
facilitate the implementation of graph algorithms. These programming
facilities are further separated into <em>GraphBLAS containers</em>,
which include matrices and vectors, <em>GraphBLAS operations</em>, which
are algorithms such as matrix-vector multiplication that operate over
GraphBLAS containers, and <em>GraphBLAS operators</em>, which are binary
and unary operators that operate over scalar elements that may be held
in a container. The C++ API also defines a series of <em>concepts</em>
defining the interface a container or operator must fulfill in order to
to be used with a particular operation, as well as <em>views</em>, which
provide lazily evaluated, mutated views of a GraphBLAS object.</p>
<h2 id="graphblas-containers">GraphBLAS Containers</h2>
<p>GraphBLAS containers, which include matrices and vectors, are sparse
data structures holding a collection of stored scalar values. Each
GraphBLAS container has a shape, which defines the dimension(s) of the
object. Stored values can be inserted at indices within the dimensions
of the object. Since GraphBLAS containers are sparse, they keep explicit
track of which index locations in the object hold stored values. There
is no implied zero value associated with a GraphBLAS container, since
the annhilator value will change from operation to operation, and the
insertion of explicit “zeros” could cause incorrect results. As such, no
GraphBLAS operation will arbitrarily insert explicit zeros. In the
GraphBLAS C++ API, each container has associated with it a scalar type,
which is the type of the stored scalar values, as well as an index type,
which is the type used to indicate the locations of stored values, as
well as the matrix shape.</p>
<p><strong><em>TODO: be more specific here. Could use some help from
math spec?</em></strong></p>
<h3 id="matrices-1">Matrices</h3>
<p>GraphBLAS matrices are two-dimensional sparse arrays. As previously
discussed, they have a scalar type, which defines the type of scalar
values stored inside the matrix, as well as an index type, which is used
to refer to the row and column index of each stored value. For a matrix
type <code>A</code>, these types can be retrieved using the expression
<code>grb::matrix_scalar_t&lt;A&gt;</code> to retrieve the scalar type
and <code>grb::matrix_index_t&lt;A&gt;</code> to retrieve the index
type. In the GraphBLAS C++ API, matrices are associative arrays similar
to instantiations of <code>std::unordered_map</code>. They map keys,
which are row and column indices, to values, which are the stored scalar
values. Like the C++ standard library’s associative containers,
GraphBLAS matrices are ranges, and iterating through a GraphBLAS matrix
reveals a collection of tuples, with each tuple holding a key and value.
The key is a tuple-like type holding the row and column indices, and the
value is the stored scalar value. The row and column are provided only
as const references, while the value may be mutated. Matrices also
support insert, assign, and find operations to write or read to a
particular location in the matrix.</p>
<h3 id="vectors-1">Vectors</h3>
<p>GraphBLAS similars are analogous to matrices, except that they are
only one-dimensional sparse arrays. They hold a scalar type, which
defines the scalar values stored inside the vector, as well as an index
type, which holds the index of an element within the vector. For a
vector <code>V</code>, these types can be retrieved with the expressions
<code>grb::vector_scalar_t&lt;V&gt;</code> and
<code>grb::vector_index_t&lt;V&gt;</code>. Like matrices, vectors are
associative arrays, except that their key values are a single index type
element, and not a tuple. Like matrices, vectors are ranges, with the
value type being a tuple holding the index type and scalar type, with
only the scalar type being mutable if the vector is non-const.
Individual elements can be modified using insert, assign, and find.</p>
<h1 id="grbmatrix"><code>grb::matrix</code></h1>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>integral<span class="op"> </span>I <span class="op">=</span> <span class="bu">std::</span>size_t<span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>          <span class="kw">typename</span> Hint <span class="op">=</span> grb<span class="op">::</span>sparse<span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>          <span class="kw">typename</span> Allocator <span class="op">=</span> <span class="bu">std::</span>allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> grb<span class="op">::</span>matrix<span class="op">;</span></span></code></pre></div>
<h2 id="template-parameters">Template Parameters</h2>
<p><code>T</code> - type of scalar values stored in the matrix</p>
<p><code>I</code> - type, satisfying <code>std::integral</code>, used to
store indices in the matrix</p>
<p><code>Hint</code> - one or a composition of compile-time hints that
may be used to affect the backend storage type</p>
<p><code>Allocator</code> - allocator type used to allocate memory for
the matrix</p>
<h2 id="member-types">Member Types</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Member Type</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>scalar_type</code></td>
<td><code>T</code>, the type of elements stored in the matrix</td>
</tr>
<tr class="even">
<td><code>index_type</code></td>
<td><code>I</code>, an integer type used to store matrix indices</td>
</tr>
<tr class="odd">
<td><code>key_type</code></td>
<td>A tuple-like type storing two <code>index_type</code> elements</td>
</tr>
<tr class="even">
<td><code>map_type</code></td>
<td><code>scalar_type</code></td>
</tr>
<tr class="odd">
<td><code>value_type</code></td>
<td><code>grb::matrix_entry&lt;T, I&gt;</code>, a tuple-like type
storing the indices and the stored element</td>
</tr>
<tr class="even">
<td><code>size_type</code></td>
<td>A large unsigned integer type, usually <code>std::size_t</code></td>
</tr>
<tr class="odd">
<td><code>difference_type</code></td>
<td>A large signed integer type, usually
<code>std::ptrdiff_t</code></td>
</tr>
<tr class="even">
<td><code>allocator_type</code></td>
<td><code>Allocator</code></td>
</tr>
<tr class="odd">
<td><code>iterator</code></td>
<td>An iterator type fulfilling <code>std::forward_iterator</code></td>
</tr>
<tr class="even">
<td><code>const_iterator</code></td>
<td>A const iterator fulfilling <code>std::forward_iterator</code></td>
</tr>
<tr class="odd">
<td><code>reference</code></td>
<td><code>grb::matrix_reference&lt;T, I&gt;</code></td>
</tr>
<tr class="even">
<td><code>const_reference</code></td>
<td><code>grb::matrix_reference&lt;const T, I&gt;</code></td>
</tr>
<tr class="odd">
<td><code>scalar_reference</code></td>
<td>Reference to <code>scalar_type</code></td>
</tr>
<tr class="even">
<td><code>const_scalar_reference</code></td>
<td>Const reference to <code>scalar_type</code></td>
</tr>
<tr class="odd">
<td><code>hint_type</code></td>
<td><code>Hint</code></td>
</tr>
</tbody>
</table>
<h2 id="methods">Methods</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>(constructor)</code></td>
<td>Constructs matrix</td>
</tr>
<tr class="even">
<td><code>(destructor)</code></td>
<td>Destructs matrix</td>
</tr>
<tr class="odd">
<td><code>operator=</code></td>
<td>Assigns matrix</td>
</tr>
<tr class="even">
<td><code>size</code></td>
<td>Number of stored elements in matrix</td>
</tr>
<tr class="odd">
<td><code>max_size</code></td>
<td>Returns the maximum possible number of elements</td>
</tr>
<tr class="even">
<td><code>empty</code></td>
<td>Return whether the matrix is empty</td>
</tr>
<tr class="odd">
<td><code>shape</code></td>
<td>Return the dimensions of the matrix</td>
</tr>
<tr class="even">
<td><code>begin</code> <br /><code>cbegin</code></td>
<td>Returns iterator to beginning of container</td>
</tr>
<tr class="odd">
<td><code>end</code> <br /><code>cend</code></td>
<td>Returns iterator to one past last element in container</td>
</tr>
<tr class="even">
<td><code>reshape</code></td>
<td>Modify dimensions of the matrix</td>
</tr>
<tr class="odd">
<td><code>clear</code></td>
<td>Clears all elements from the container</td>
</tr>
<tr class="even">
<td><code>insert</code></td>
<td>Insert elements</td>
</tr>
<tr class="odd">
<td><code>insert_or_assign</code></td>
<td>Inserts or assigns elements</td>
</tr>
<tr class="even">
<td><code>erase</code></td>
<td>Erases elements</td>
</tr>
<tr class="odd">
<td><code>find</code></td>
<td>Finds an element</td>
</tr>
<tr class="even">
<td><code>at</code></td>
<td>Access element</td>
</tr>
<tr class="odd">
<td><code>operator[]</code></td>
<td>Access or insert element</td>
</tr>
</tbody>
</table>
<h2 id="grbmatrixmatrix"><code>grb::matrix::matrix</code></h2>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>matrix<span class="op">(</span><span class="at">const</span> Allocator<span class="op">&amp;</span> alloc <span class="op">=</span> Allocator<span class="op">());</span>    <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>matrix<span class="op">(</span>grb<span class="op">::</span>index<span class="op">&lt;</span><span class="dt">index_type</span><span class="op">&gt;</span> shape<span class="op">,</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>       <span class="at">const</span> Allocator<span class="op">&amp;</span> alloc <span class="op">=</span> Allocator<span class="op">());</span>    <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>matrix<span class="op">(</span><span class="at">const</span> matrix<span class="op">&amp;</span> other<span class="op">);</span>                     <span class="op">(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>matrix<span class="op">(</span>matrix<span class="op">&amp;&amp;</span> other<span class="op">);</span>                          <span class="op">(</span><span class="dv">4</span><span class="op">)</span></span></code></pre></div>
<p>Constructs new <code>grb::matrix</code> data structure.</p>
<ol type="1">
<li>Constructs an empty matrix of dimension <code>0 x 0</code>.</li>
<li>Constructs an empty matrix of dimension
<code>shape[0] x shape[1]</code>.</li>
<li>Copy constructor. Constructs a matrix with the dimensions and
contents of <code>other</code>.</li>
<li>Move constructor. Constructs a matrix with the dimensions and
contents of <code>other</code> using move semantics. After the move,
<code>other</code> is guaranteed to be empty.</li>
</ol>
<h3 id="parameters">Parameters</h3>
<p><code>shape</code> - shape of the matrix to be constructed</p>
<p><code>other</code> - another matrix to construct the new matrix
from</p>
<h3 id="complexity">Complexity</h3>
<ol type="1">
<li>Constant</li>
<li>Implementation defined</li>
<li>Implementation defined</li>
<li>Implementation defined</li>
</ol>
<h3 id="exceptions">Exceptions</h3>
<p>Calls to <code>Allocator::allocate</code> may throw.</p>
<h2 id="grbmatrixmatrix-1"><code>grb::matrix::~matrix</code></h2>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">~</span>matrix<span class="op">();</span></span></code></pre></div>
<p>Destroys the <code>grb::matrix</code>. The destructors of the
elements are called and storage is deallocated.</p>
<h3 id="complexity-1">Complexity</h3>
<p>Linear in the size of the vector.</p>
<h2 id="grbmatrixoperator"><code>grb::matrix::operator=</code></h2>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>matrix<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> matrix<span class="op">&amp;</span> other<span class="op">);</span>          <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>matrix<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>matrix<span class="op">&amp;&amp;</span> other<span class="op">);</span>               <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span></code></pre></div>
<p>Replaces the matrix with the contents and shape of another
matrix.</p>
<ol type="1">
<li>Copy assignment operator. Modifies the shape of the matrix to be
equal to that of <code>other</code> and copies the stored values to be
the same as <code>other</code>.</li>
<li>Move constructor. Replaces the contents of the matrix with those of
<code>other</code> using move semantics. After the move assignment
operation completes, <code>other</code> is in a valid but indeterminate
state.</li>
</ol>
<h3 id="parameters-1">Parameters</h3>
<p><code>other</code> - another matrix to assign the matrix to</p>
<h3 id="complexity-2">Complexity</h3>
<ol type="1">
<li>Implementation defined</li>
<li>Constant</li>
</ol>
<h3 id="exceptions-1">Exceptions</h3>
<ol type="1">
<li>Calls to <code>Allocator::allocate</code> may throw.</li>
</ol>
<h2 id="grbmatrixsize"><code>grb::matrix::size</code></h2>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_type</span> size<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns the number of elements stored in the matrix.</p>
<h3 id="parameters-2">Parameters</h3>
<p>(none)</p>
<h3 id="return-value">Return value</h3>
<p>Number of stored elements.</p>
<h3 id="complexity-3">Complexity</h3>
<p>Constant</p>
<h2 id="grbmatrixmax_size"><code>grb::matrix::max_size</code></h2>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_type</span> max_size<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns the maximum possible number of elements that could be stored
in the matrix due to system or implementation limitations.</p>
<h3 id="parameters-3">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-1">Return value</h3>
<p>Maximum possible number of elements.</p>
<h3 id="complexity-4">Complexity</h3>
<p>Constant</p>
<h2 id="grbmatrixempty"><code>grb::matrix::empty</code></h2>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> empty<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns whether the matrix is empty, that is where
<code>size() == 0</code>.</p>
<h3 id="parameters-4">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-2">Return value</h3>
<p>Whether the matrix is empty.</p>
<h3 id="complexity-5">Complexity</h3>
<p>Constant</p>
<h2 id="grbmatrixshape"><code>grb::matrix::shape</code></h2>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> shape<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns the dimensions of the matrix.</p>
<h3 id="parameters-5">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-3">Return value</h3>
<p>Dimensions of the matrix.</p>
<h3 id="complexity-6">Complexity</h3>
<p>Constant</p>
<h2
id="grbmatrixbegin-and-grbmatrixcbegin"><code>grb::matrix::begin</code>
and <code>grb::matrix::cbegin</code></h2>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>iterator begin<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>const_iterator begin<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>const_iterator cbegin<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns an iterator to the first element of the matrix data
structure. If the matrix is empty, returns an element that compares as
equal to <code>end()</code>.</p>
<h3 id="parameters-6">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-4">Return value</h3>
<p>Iterator to the first element</p>
<h3 id="complexity-7">Complexity</h3>
<p>Constant</p>
<h2 id="grbmatrixend-and-grbmatrixcend"><code>grb::matrix::end</code>
and <code>grb::matrix::cend</code></h2>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>iterator end<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>const_iterator end<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>const_iterator cend<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns an iterator to one past the last element of the matrix data
structure. This element is used only to signify the end of the
container, and accessing it has undefined behavior.</p>
<h3 id="parameters-7">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-5">Return value</h3>
<p>Iterator to one past the last element.</p>
<h3 id="complexity-8">Complexity</h3>
<p>Constant</p>
<h2 id="grbmatrixreshape"><code>grb::matrix::reshape</code></h2>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reshape<span class="op">(</span>grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> shape<span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Reshape the matrix. That is, modify the matrix dimensions such that
matrix shape is now <code>shape[0]</code> x <code>shape[1]</code>. If
any nonzeros lie outside of the new matrix shape, they are removed from
the matrix</p>
<h3 id="parameters-8">Parameters</h3>
<p><code>shape</code> - New matrix shape</p>
<h3 id="return-value-6">Return value</h3>
<p>None</p>
<h3 id="complexity-9">Complexity</h3>
<p>Implementation defined</p>
<h3 id="exceptions-2">Exceptions</h3>
<p>Calls to <code>Allocator::allocate</code> may throw.</p>
<h2 id="grbmatrixclear"><code>grb::matrix::clear</code></h2>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> clear<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Clear all stored scalar values from the matrix. The matrix maintains
the same shape, but after return will now have a size of 0.</p>
<h3 id="complexity-10">Complexity</h3>
<p>Implementation defined</p>
<h2 id="grbmatrixinsert"><code>grb::matrix::insert</code></h2>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> InputIt<span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> insert<span class="op">(</span>InputIt first<span class="op">,</span> InputIt last<span class="op">);</span>                    <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span>iterator<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;</span> insert<span class="op">(</span><span class="at">const</span> <span class="dt">value_type</span><span class="op">&amp;</span> value<span class="op">);</span>   <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span>iterator<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;</span> insert<span class="op">(</span><span class="dt">value_type</span><span class="op">&amp;&amp;</span> value<span class="op">);</span>        <span class="op">(</span><span class="dv">3</span><span class="op">)</span></span></code></pre></div>
<p>Inserts an element or number of elements into the matrix, if the
matrix doesn’t already contain a stored element at the corresponding
index.</p>
<ol type="1">
<li><p>Insert each element in the range <code>[first, last)</code> if an
element does not already exist in the matrix at the corresponding index.
If multiple elements in <code>[first, last)</code> have the same
indices, it is undefined which element is inserted.</p></li>
<li><p>and (3) Insert the element <code>value</code> if an element does
not already exist at the corresponding index in the matrix.</p></li>
</ol>
<h3 id="parameters-9">Parameters</h3>
<p><code>first</code>, <code>last</code> - Range of elements to
insert</p>
<p><code>value</code> - element to insert</p>
<h3 id="return-value-7">Return value</h3>
<ol type="1">
<li><p>None</p></li>
<li><p>and (3) return a <code>std::pair</code> containing an
<code>iterator</code> and a <code>bool</code> value. The
<code>bool</code> value indicates whether or not the insertion was
successful. If the insertion was successful, the first value contains an
iterator to the newly inserted element. If it was unsuccessful, it
contains an iterator to the element that prevented insertion.</p></li>
</ol>
<h3 id="complexity-11">Complexity</h3>
<p>Implementation defined</p>
<h2
id="grbmatrixinsert_or_assign"><code>grb::matrix::insert_or_assign</code></h2>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> M<span class="op">&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span>iterator<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;</span> insert_or_assign<span class="op">(</span><span class="dt">key_type</span> k<span class="op">,</span> M<span class="op">&amp;&amp;</span> obj<span class="op">);</span></span></code></pre></div>
<p>Inserts an element into index <code>k</code> in the matrix and
assigns to the scalar value if one already exists.</p>
<p>If an element already exists at index location <code>k</code>,
assigns <code>std::forward&lt;M&gt;(obj)</code> to the scalar value
stored at that index. If no element exists, inserts <code>obj</code> at
the index as if by calling <code>insert</code> with
<code>value_type(k, std::forward&lt;M&gt;(obj))</code>.</p>
<h3 id="parameters-10">Parameters</h3>
<p><code>k</code> - the index location to assign <code>obj</code></p>
<p><code>obj</code> - the scalar value to be assigned</p>
<h3 id="type-requirements">Type Requirements</h3>
<p><code>M</code> must fulfill
<code>std::is_assignable&lt;scalar_type&amp;, M&gt;</code></p>
<h3 id="return-value-8">Return Value</h3>
<p>Returns an <code>std::pair</code> with the first element holding an
iterator to the newly inserted or assigned value and the second element
holding a <code>bool</code> value that is <code>true</code> if the
element was inserted and <code>false</code> otherwise.</p>
<h3 id="complexity-12">Complexity</h3>
<p>Implementation defined.</p>
<h2 id="grbmatrixerase"><code>grb::matrix::erase</code></h2>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_type</span> erase<span class="op">(</span>grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> index<span class="op">);</span></span></code></pre></div>
<p>Erases the element stored at index <code>index</code> if one
exists.</p>
<h3 id="parameters-11">Parameters</h3>
<p><code>index</code> - the index of element to erase</p>
<h3 id="return-value-9">Return Value</h3>
<p>Returns the number of elements erased (0 or 1).</p>
<h3 id="complexity-13">Complexity</h3>
<p>Implementation defined.</p>
<h2 id="grbmatrixfind"><code>grb::matrix::find</code></h2>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>iterator find<span class="op">(</span>grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> index<span class="op">);</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>const_iterator find<span class="op">(</span>grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> index<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Finds the element at location (<code>index[0]</code>,
<code>index[1]</code>) in the matrix, returning an iterator to the
element. If no element is present at the location, returns
<code>end()</code>.</p>
<h3 id="parameters-12">Parameters</h3>
<p><code>index</code> - Location of the matrix element to find</p>
<h3 id="return-value-10">Return value</h3>
<p>An iterator pointing to the matrix element at the corresponding
index, or <code>end()</code> if there is no element at the location.</p>
<h3 id="complexity-14">Complexity</h3>
<p>Implementation defined</p>
<h2 id="grbmatrixoperator-1"><code>grb::matrix::operator[]</code></h2>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>scalar_reference <span class="kw">operator</span><span class="op">[](</span>grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> index<span class="op">);</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>const_scalar_reference <span class="kw">operator</span><span class="op">[](</span>grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> index<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Returns a reference to the scalar value stored at location
(<code>index[0]</code>, <code>index[1]</code>) in the matrix. If no
value is stored at the location, inserts a default constructed value at
the location and returns a reference to it.</p>
<h3 id="parameters-13">Parameters</h3>
<p><code>index</code> - Location of the matrix element</p>
<h3 id="return-value-11">Return value</h3>
<p>A reference to the scalar value at location (<code>index[0]</code>,
<code>[index[1]</code>).</p>
<h3 id="complexity-15">Complexity</h3>
<p>Implementation defined</p>
<h2 id="grbmatrixat"><code>grb::matrix::at</code></h2>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>scalar_reference at<span class="op">(</span>grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> index<span class="op">);</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>const_scalar_reference at<span class="op">(</span>grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> index<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Returns a reference to the scalar value stored at location
(<code>index[0]</code>, <code>index[1]</code>) in the matrix. If no
value is stored at the location, throws the exception
<code>grb::out_of_range</code>.</p>
<h3 id="parameters-14">Parameters</h3>
<p><code>index</code> - Location of the matrix element</p>
<h3 id="return-value-12">Return value</h3>
<p>A reference to the scalar value at location (<code>index[0]</code>,
<code>[index[1]</code>).</p>
<h3 id="complexity-16">Complexity</h3>
<p>Implementation defined</p>
<h3 id="exceptions-3">Exceptions</h3>
<p>If no element exists at location (<code>index[0]</code>,
<code>index[1]</code>), throws the exception
<code>grb::out_of_range</code>.</p>
<h1 id="grbvector"><code>grb::vector</code></h1>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>integral<span class="op"> </span>I <span class="op">=</span> <span class="bu">std::</span>size_t<span class="op">,</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>          <span class="kw">typename</span> Hint <span class="op">=</span> grb<span class="op">::</span>sparse<span class="op">,</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>          <span class="kw">typename</span> Allocator <span class="op">=</span> <span class="bu">std::</span>allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> grb<span class="op">::</span>vector<span class="op">;</span></span></code></pre></div>
<h2 id="template-parameters-1">Template Parameters</h2>
<p><code>T</code> - type of scalar values stored in the vector</p>
<p><code>I</code> - type, satisfying <code>std::integral</code>, used to
store indices in the vector</p>
<p><code>Hint</code> - one or a composition of compile-time hints that
may be used to affect the backend storage type</p>
<p><code>Allocator</code> - allocator type used to allocate memory</p>
<h2 id="member-types-1">Member Types</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Member Type</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>scalar_type</code></td>
<td><code>T</code>, the type of scalar elements stored in the
vector</td>
</tr>
<tr class="even">
<td><code>index_type</code></td>
<td><code>I</code>, an integer type used to store vector indices</td>
</tr>
<tr class="odd">
<td><code>key_type</code></td>
<td><code>index_type</code></td>
</tr>
<tr class="even">
<td><code>map_type</code></td>
<td><code>scalar_type</code></td>
</tr>
<tr class="odd">
<td><code>value_type</code></td>
<td><code>grb::vector_entry&lt;T, I&gt;</code>, a tuple-like type
storing the indices and the stored element</td>
</tr>
<tr class="even">
<td><code>size_type</code></td>
<td>A large unsigned integer type, usually <code>std::size_t</code></td>
</tr>
<tr class="odd">
<td><code>difference_type</code></td>
<td>A large signed integer type, usually
<code>std::ptrdiff_t</code></td>
</tr>
<tr class="even">
<td><code>allocator_type</code></td>
<td><code>Allocator</code></td>
</tr>
<tr class="odd">
<td><code>iterator</code></td>
<td>An iterator type fulfilling <code>std::forward_iterator</code></td>
</tr>
<tr class="even">
<td><code>const_iterator</code></td>
<td>A const iterator fulfilling <code>std::forward_iterator</code></td>
</tr>
<tr class="odd">
<td><code>reference</code></td>
<td><code>grb::vector_ref&lt;T, I&gt;</code></td>
</tr>
<tr class="even">
<td><code>const_reference</code></td>
<td><code>grb::vector_ref&lt;const T, I&gt;</code></td>
</tr>
<tr class="odd">
<td><code>scalar_reference</code></td>
<td>Reference to <code>scalar_type</code></td>
</tr>
<tr class="even">
<td><code>const_scalar_reference</code></td>
<td>Const reference to <code>scalar_type</code></td>
</tr>
<tr class="odd">
<td><code>hint_type</code></td>
<td><code>Hint</code></td>
</tr>
</tbody>
</table>
<h2 id="methods-1">Methods</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>(constructor)</code></td>
<td>Constructs vector</td>
</tr>
<tr class="even">
<td><code>size</code></td>
<td>Number of stored elements in vector</td>
</tr>
<tr class="odd">
<td><code>max_size</code></td>
<td>Returns the maximum possible number of elements</td>
</tr>
<tr class="even">
<td><code>empty</code></td>
<td>Return whether the vector is empty</td>
</tr>
<tr class="odd">
<td><code>shape</code></td>
<td>Return the dimension of the vector</td>
</tr>
<tr class="even">
<td><code>begin</code> <br /><code>cbegin</code></td>
<td>Returns iterator to beginning of container</td>
</tr>
<tr class="odd">
<td><code>end</code> <br /><code>cend</code></td>
<td>Returns iterator to one past last element in container</td>
</tr>
<tr class="even">
<td><code>reshape</code></td>
<td>Modify the dimension of the vector</td>
</tr>
<tr class="odd">
<td><code>clear</code></td>
<td>Clears all elements from the container</td>
</tr>
<tr class="even">
<td><code>insert</code></td>
<td>Insert elements</td>
</tr>
<tr class="odd">
<td><code>insert_or_assign</code></td>
<td>Inserts or assigns elements</td>
</tr>
<tr class="even">
<td><code>find</code></td>
<td>Finds an element</td>
</tr>
<tr class="odd">
<td><code>operator[]</code></td>
<td>Access or insert element</td>
</tr>
</tbody>
</table>
<h2 id="grbvectorvector"><code>grb::vector::vector</code></h2>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">();</span>                                           <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">(</span><span class="at">const</span> Allocator<span class="op">&amp;</span> alloc<span class="op">);</span>                     <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>vector<span class="op">(</span><span class="dt">index_type</span> shape<span class="op">);</span>                           <span class="op">(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>vector<span class="op">(</span><span class="dt">index_type</span> shape<span class="op">,</span> <span class="at">const</span> Allocator<span class="op">&amp;</span> alloc<span class="op">);</span>   <span class="op">(</span><span class="dv">4</span><span class="op">)</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>vector<span class="op">(</span><span class="at">const</span> vector<span class="op">&amp;</span> other<span class="op">);</span>                        <span class="op">(</span><span class="dv">5</span><span class="op">)</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>vector<span class="op">(</span>vector<span class="op">&amp;&amp;</span> other<span class="op">);</span>                             <span class="op">(</span><span class="dv">6</span><span class="op">)</span></span></code></pre></div>
<p>Constructs new <code>grb::vector</code> data structure.</p>
<ol type="1">
<li>and 2) Constructs an empty vector of dimension 0.</li>
<li>and 4) Constructs an empty vector of dimension
<code>shape</code>.</li>
<li>Copy constructor</li>
<li>Move constructor</li>
</ol>
<h3 id="parameters-15">Parameters</h3>
<p><code>shape</code> - shape of the vector to be constructed</p>
<h3 id="complexity-17">Complexity</h3>
<ol type="1">
<li>Constant</li>
<li>Implementation defined</li>
</ol>
<h3 id="exceptions-4">Exceptions</h3>
<p>May throw <code>std::bad_alloc</code>.</p>
<h2 id="grbvectorsize"><code>grb::vector::size</code></h2>
<div class="sourceCode" id="cb22"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_type</span> size<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns the number of elements stored in the vector.</p>
<h3 id="parameters-16">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-13">Return value</h3>
<p>Number of stored elements.</p>
<h3 id="complexity-18">Complexity</h3>
<p>Constant</p>
<h2 id="grbvectormax_size"><code>grb::vector::max_size</code></h2>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_type</span> max_size<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns the maximum possible number of elements that could be stored
in the vector due to platform or implementation limitations.</p>
<h3 id="parameters-17">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-14">Return value</h3>
<p>Maximum possible number of elements.</p>
<h3 id="complexity-19">Complexity</h3>
<p>Constant</p>
<h2 id="grbvectorempty"><code>grb::vector::empty</code></h2>
<div class="sourceCode" id="cb24"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> empty<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns whether the vector is empty, that is where
<code>size() == 0</code>.</p>
<h3 id="parameters-18">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-15">Return value</h3>
<p>Whether the vector is empty.</p>
<h3 id="complexity-20">Complexity</h3>
<p>Constant</p>
<h2 id="grbvectorshape"><code>grb::vector::shape</code></h2>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">index_type</span> shape<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns the dimension of the vector.</p>
<h3 id="parameters-19">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-16">Return value</h3>
<p>Dimension of the vector.</p>
<h3 id="complexity-21">Complexity</h3>
<p>Constant</p>
<h2
id="grbvectorbegin-and-grbvectorcbegin"><code>grb::vector::begin</code>
and <code>grb::vector::cbegin</code></h2>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>iterator begin<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>const_iterator begin<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>const_iterator cbegin<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns an iterator to the first element of the vector data
structure. If the vector is empty, returns an element that compares as
equal to <code>end()</code>.</p>
<h3 id="parameters-20">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-17">Return value</h3>
<p>Iterator to the first element</p>
<h3 id="complexity-22">Complexity</h3>
<p>Constant</p>
<h2 id="grbvectorend-and-grbvectorcend"><code>grb::vector::end</code>
and <code>grb::vector::cend</code></h2>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>iterator end<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>const_iterator end<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>const_iterator cend<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns an iterator to one past the last element of the vector data
structure. This element is used only to signify the end of the
container, and accessing it has undefined behavior.</p>
<h3 id="parameters-21">Parameters</h3>
<p>(none)</p>
<h3 id="return-value-18">Return value</h3>
<p>Iterator to one past the last element.</p>
<h3 id="complexity-23">Complexity</h3>
<p>Constant</p>
<h2 id="grbvectorreshape"><code>grb::vector::reshape</code></h2>
<div class="sourceCode" id="cb28"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reshape<span class="op">(</span><span class="dt">index_type</span> shape<span class="op">);</span></span></code></pre></div>
<p>Reshape the vector. That is, modify the vector dimension such that
vector is now of dimension <code>shape</code>. If any nonzeros lie
outside of the new vector shape, they are removed from the vector.</p>
<h3 id="parameters-22">Parameters</h3>
<p><code>shape</code> - New vector shape</p>
<h3 id="return-value-19">Return value</h3>
<p>None</p>
<h3 id="complexity-24">Complexity</h3>
<p>Implementation defined</p>
<h2 id="grbvectorclear"><code>grb::vector::clear</code></h2>
<div class="sourceCode" id="cb29"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> clear<span class="op">();</span></span></code></pre></div>
<p>Clear all stored scalar values from the vector. The vector maintains
the same shape, but after return will now have a size of 0.</p>
<h3 id="complexity-25">Complexity</h3>
<p>Implementation defined</p>
<h2 id="grbvectorinsert"><code>grb::vector::insert</code></h2>
<div class="sourceCode" id="cb30"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> InputIt<span class="op">&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> insert<span class="op">(</span>InputIt first<span class="op">,</span> InputIt last<span class="op">);</span>                    <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span>iterator<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;</span> insert<span class="op">(</span><span class="at">const</span> <span class="dt">value_type</span><span class="op">&amp;</span> value<span class="op">);</span>   <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span>iterator<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;</span> insert<span class="op">(</span><span class="dt">value_type</span><span class="op">&amp;&amp;</span> value<span class="op">);</span>        <span class="op">(</span><span class="dv">3</span><span class="op">)</span></span></code></pre></div>
<p>Inserts an element or number of elements into the vector, if the
vector doesn’t already contain a stored element at the corresponding
index.</p>
<ol type="1">
<li><p>Insert elements in the range <code>[first, last)</code> if an
element does not already exist in the vector at the corresponding index.
If multiple elements in <code>[first, last)</code> have the same
indices, it is undefined which element is inserted.</p></li>
<li><p>and (3) Insert the element <code>value</code> if an element does
not already exist at the corresponding index in the vector.</p></li>
</ol>
<h3 id="parameters-23">Parameters</h3>
<p><code>first</code>, <code>last</code> - Range of elements to
insert</p>
<p><code>value</code> - element to insert</p>
<h3 id="return-value-20">Return value</h3>
<ol type="1">
<li><p>None</p></li>
<li><p>and (3) return a <code>std::pair</code> containing an
<code>iterator</code> and a <code>bool</code> value. The
<code>bool</code> value indicates whether or not the insertion was
successful. If the insertion was successful, the first value contains an
iterator to the newly inserted element. If it was unsuccessful, it
contains an iterator to the element that prevented insertion.</p></li>
</ol>
<h3 id="complexity-26">Complexity</h3>
<p>Implementation defined</p>
<h2
id="grbvectorinsert_or_assign"><code>grb::vector::insert_or_assign</code></h2>
<div class="sourceCode" id="cb31"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> M<span class="op">&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span>iterator<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;</span> insert_or_assign<span class="op">(</span><span class="dt">key_type</span> k<span class="op">,</span> M<span class="op">&amp;&amp;</span> obj<span class="op">);</span></span></code></pre></div>
<p>Inserts an element into index <code>k</code> in the vector and
assigns to the scalar value if one already exists.</p>
<p>If an element already exists at index location <code>k</code>,
assigns <code>std::forward&lt;M&gt;(obj)</code> to the scalar value
stored at that index. If no element exists, inserts <code>obj</code> at
the index as if by calling <code>insert</code> with
<code>value_type(k, std::forward&lt;M&gt;(obj))</code>.</p>
<h3 id="parameters-24">Parameters</h3>
<p><code>k</code> - the index location to assign <code>obj</code></p>
<p><code>obj</code> - the scalar value to be assigned</p>
<h3 id="type-requirements-1">Type Requirements</h3>
<p><code>M</code> must fulfill
<code>std::is_assignable&lt;scalar_type&amp;, M&gt;</code></p>
<h3 id="return-value-21">Return Value</h3>
<p>Returns an <code>std::pair</code> with the first element holding an
iterator to the newly inserted or assigned value and the second element
holding a <code>bool</code> value that is <code>true</code> if the
element was inserted and <code>false</code> otherwise.</p>
<h3 id="complexity-27">Complexity</h3>
<p>Implementation defined.</p>
<h2 id="grbvectorerase"><code>grb::vector::erase</code></h2>
<div class="sourceCode" id="cb32"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_type</span> erase<span class="op">(</span><span class="dt">index_type</span> index<span class="op">);</span></span></code></pre></div>
<p>Erases the element stored at index <code>index</code> if one
exists.</p>
<h3 id="parameters-25">Parameters</h3>
<p><code>index</code> - the index of the scalar value to erase</p>
<h3 id="return-value-22">Return Value</h3>
<p>Returns the number of elements erased (0 or 1).</p>
<h3 id="complexity-28">Complexity</h3>
<p>Implementation defined.</p>
<h2 id="grbvectorfind"><code>grb::vector::find</code></h2>
<div class="sourceCode" id="cb33"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>iterator find<span class="op">(</span><span class="dt">index_type</span> index<span class="op">);</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>const_iterator find<span class="op">(</span><span class="dt">index_type</span> index<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Finds the element at location <code>index</code> in the vector,
returning an iterator to the element. If no element is present at the
location, returns <code>end()</code>.</p>
<h3 id="parameters-26">Parameters</h3>
<p><code>index</code> - Location of the vector element to find</p>
<h3 id="return-value-23">Return value</h3>
<p>An iterator pointing to the vector element at the corresponding
index, or <code>end()</code> if there is no element at the location.</p>
<h3 id="complexity-29">Complexity</h3>
<p>Implementation defined</p>
<h2 id="grbvectoroperator"><code>grb::vector::operator[]</code></h2>
<div class="sourceCode" id="cb34"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>scalar_reference <span class="kw">operator</span><span class="op">[](</span><span class="dt">index_type</span> index<span class="op">);</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>const_scalar_reference <span class="kw">operator</span><span class="op">[](</span><span class="dt">index_type</span> index<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Returns a reference to the scalar value stored at location
<code>index</code> in the vector. If no value is stored at the location,
inserts a default constructed value at the location and returns a
reference to it.</p>
<h3 id="parameters-27">Parameters</h3>
<p><code>index</code> - Location of the vector element</p>
<h3 id="return-value-24">Return value</h3>
<p>A reference to the scalar value at location <code>index</code>.</p>
<h3 id="complexity-30">Complexity</h3>
<p>Implementation defined</p>
<h2 id="grbvectorat"><code>grb::vector::at</code></h2>
<div class="sourceCode" id="cb35"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>scalar_reference at<span class="op">(</span><span class="dt">index_type</span> index<span class="op">);</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>const_scalar_reference at<span class="op">(</span><span class="dt">index_type</span> index<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Returns a reference to the scalar value stored at location
<code>index</code> in the vector. If no value is stored at the location,
throws the exception <code>grb::out_of_range</code>.</p>
<h3 id="parameters-28">Parameters</h3>
<p><code>index</code> - Location of the vector element</p>
<h3 id="return-value-25">Return value</h3>
<p>A reference to the scalar value at location <code>index</code>.</p>
<h3 id="complexity-31">Complexity</h3>
<p>Implementation defined</p>
<h3 id="exceptions-5">Exceptions</h3>
<p>If no element exists at location <code>index</code>, throws the
exception <code>grb::out_of_range</code>.</p>
<h1 id="grbindex"><code>grb::index</code></h1>
<div class="sourceCode" id="cb36"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>integral<span class="op"> </span>T<span class="op">&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> grb<span class="op">::</span>index<span class="op">;</span></span></code></pre></div>
<p><code>grb::index</code> is a tuple-like type used to store matrix
indices and dimensions.</p>
<h2 id="template-parameters-2">Template Parameters</h2>
<p><code>T</code> - type, satisfying <code>std::integral</code>, used to
store indices</p>
<h2 id="member-types-2">Member Types</h2>
<table>
<thead>
<tr class="header">
<th>Member Type</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>index_type</code></td>
<td><code>T</code></td>
</tr>
<tr class="even">
<td><code>first_type</code></td>
<td><code>T</code></td>
</tr>
<tr class="odd">
<td><code>second_type</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<h2 id="member-objects">Member Objects</h2>
<table>
<thead>
<tr class="header">
<th>Member Name</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>first</code></td>
<td><code>T</code></td>
</tr>
<tr class="even">
<td><code>second</code></td>
<td><code>T</code></td>
</tr>
</tbody>
</table>
<h2 id="methods-2">Methods</h2>
<table>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>(constructor)</code></td>
<td>Constructs index</td>
</tr>
<tr class="even">
<td><code>operator[]</code></td>
<td>Get one of the indices</td>
</tr>
<tr class="odd">
<td><code>get</code></td>
<td>Get one of the indices</td>
</tr>
</tbody>
</table>
<h1 id="sparse-storage-format-hints">Sparse Storage Format Hints</h1>
<p>This section defines compile-time hints that can be used to direct
the storage format used to organize data inside GraphBLAS objects.
Storage hints can be used as optional template arguments to
<code>grb::matrix</code>, <code>grb::vector</code>, as well as some API
functions that return a matrix or vector. These compile-time hints
provide a mechanism for users to suggest to the GraphBLAS implementation
which storage format might be most appropriate for a particular matrix.
However, these compile-time hints are indeed <em>hints</em> to the
implementation and do not enforce any change in semantics to a matrix or
vector data structure and do not require it to use any particular
storage format. GraphBLAS implementations are encouraged to document
which storage formats they support, as well as how different hints will
affect which storage formats are used.</p>
<h3 id="example">Example</h3>
<div class="sourceCode" id="cb37"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;grb/grb.hpp&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">**</span> argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Create a matrix with the `dense` compile-time hint.</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The implementation may choose to employ a dense storage format.</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>matrix<span class="op">&lt;</span><span class="dt">float</span><span class="op">,</span> <span class="bu">std::</span>size_t<span class="op">,</span> grb<span class="op">::</span>dense<span class="op">&gt;</span> x<span class="op">({</span><span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">});</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Create a matrix with the compile-time hint compose&lt;sparse, row&gt;.</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// A GraphBLAS implementation may choose to employ a compressed sparse row</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// storage format.</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>matrix<span class="op">&lt;</span><span class="dt">float</span><span class="op">,</span> <span class="bu">std::</span>size_t<span class="op">,</span> grb<span class="op">::</span>compose<span class="op">&lt;</span>grb<span class="op">::</span>sparse<span class="op">,</span> grb<span class="op">::</span>row<span class="op">&gt;&gt;</span> y<span class="op">({</span><span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">});</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// No change in data structure semantics is implied by a hint.</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>  x<span class="op">[{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>  x<span class="op">[{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">6</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>  y<span class="op">[{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>  y<span class="op">[{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">}]</span> <span class="op">=</span> <span class="fl">2.5</span><span class="op">;</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>print<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>print<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="grbsparse"><code>grb::sparse</code></h2>
<div class="sourceCode" id="cb38"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> sparse <span class="op">=</span> <span class="co">/* undefined */</span><span class="op">;</span></span></code></pre></div>
<p>Compile-time hint to suggest to the GraphBLAS implementation that a
sparse or compressed storage format is appropriate.</p>
<h2 id="grbdense"><code>grb::dense</code></h2>
<div class="sourceCode" id="cb39"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> dense <span class="op">=</span> <span class="co">/* undefined */</span><span class="op">;</span></span></code></pre></div>
<p>Compile-time hint to suggest to the GraphBLAS implementation that a
dense storage format is appropriate.</p>
<h2 id="grbrow"><code>grb::row</code></h2>
<div class="sourceCode" id="cb40"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> row <span class="op">=</span> <span class="co">/* undefined */</span><span class="op">;</span></span></code></pre></div>
<p>Compile-time hint to suggest to the GraphBLAS implementation that a
row-major storage format is appropriate.</p>
<h2 id="grbcolumn"><code>grb::column</code></h2>
<div class="sourceCode" id="cb41"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> column <span class="op">=</span> <span class="co">/* undefined */</span><span class="op">;</span></span></code></pre></div>
<p>Compile-time hint to suggest to the GraphBLAS implementation that a
column-major storage format is appropriate.</p>
<h2 id="grbcompose"><code>grb::compose</code></h2>
<div class="sourceCode" id="cb42"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Hints<span class="op">&gt;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> compose <span class="op">=</span> <span class="co">/* undefined */</span><span class="op">;</span></span></code></pre></div>
<p>Type alias used to combine multiple compile-time hints together.</p>
<h1 id="views">Views</h1>
<h2 id="grbviewstranspose">grb::views::transpose</h2>
<div class="sourceCode" id="cb43"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> views <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="co">/* unspecified */</span> transpose <span class="op">=</span> <span class="co">/* unspecified */</span><span class="op">;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h5 id="call-signature">Call signature</h5>
<div class="sourceCode" id="cb44"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange M<span class="op">&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>MatrixRange <span class="kw">auto</span> transpose<span class="op">(</span>M<span class="op">&amp;&amp;</span> matrix<span class="op">);</span></span></code></pre></div>
<h3 id="parameters-29">Parameters</h3>
<p><code>matrix</code> - a GraphBLAS matrix or matrix view</p>
<h4 id="type-requirements-2">Type Requirements</h4>
<ul>
<li><code>M</code> must meet the requirements of
<code>MatrixRange</code></li>
</ul>
<h3 id="return-value-26">Return Value</h3>
<p>Returns a matrix view that is equal to the transpose of
<code>matrix</code>, satisfying <code>MatrixRange</code>.</p>
<p>If the value returned by <code>transpose</code> outlives the lifetime
of <code>matrix</code>, then the behavior is undefined.</p>
<h2 id="grbviewstransform">grb::views::transform</h2>
<div class="sourceCode" id="cb45"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> views <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="co">/* unspecified */</span> transform <span class="op">=</span> <span class="co">/* unspecified */</span><span class="op">;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h5 id="call-signature-1">Call signature</h5>
<div class="sourceCode" id="cb46"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange M<span class="op">,</span> <span class="bu">std::</span>copy_constructible<span class="op"> </span>Fn<span class="op">&gt;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>MatrixRange <span class="kw">auto</span> transform <span class="op">(</span>M<span class="op">&amp;&amp;</span> matrix<span class="op">,</span> Fn<span class="op">&amp;&amp;</span> fn<span class="op">);</span>             <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange V<span class="op">,</span> <span class="bu">std::</span>copy_constructible<span class="op"> </span>Fn<span class="op">&gt;</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>VectorRange <span class="kw">auto</span> transform<span class="op">(</span>V<span class="op">&amp;&amp;</span> vector<span class="op">,</span> Fn<span class="op">&amp;&amp;</span> fn<span class="op">);</span>              <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span></code></pre></div>
<ol type="1">
<li><p><code>fn</code> must accept an argument of type
<code>std::ranges::range_value_t&lt;M&gt;</code> and return a value of
some type. The return type of <code>fn</code> will be the scalar type of
the transform view.</p></li>
<li><p><code>fn</code> must accept an argument of type
<code>std::ranges::range_value_t&lt;V&gt;</code> and return a value of
some type. The return type of <code>fn</code> will be the scalar type of
the transform view.</p></li>
</ol>
<h3 id="parameters-30">Parameters</h3>
<p><code>matrix</code> - a GraphBLAS matrix or matrix view satisfying
<code>MatrixRange</code></p>
<p><code>vector</code> - a GraphBLAS vector or vector view satisfying
<code>VectorRange</code></p>
<p><code>fn</code> - function used to transform matrix values
element-wise</p>
<h4 id="type-requirements-3">Type Requirements</h4>
<ul>
<li><p><code>M</code> must meet the requirements of
<code>MatrixRange</code></p></li>
<li><p><code>V</code> must meet the requirements of
<code>VectorRange</code></p></li>
</ul>
<h3 id="return-value-27">Return Value</h3>
<ol type="1">
<li><p>Returns a view of <code>matrix</code> satisfying
<code>MatrixRange</code>. The stored scalar values will correspond to
every stored scalar value in <code>matrix</code> transformed using the
function <code>fn</code>.</p></li>
<li><p>Returns a view of <code>vector</code> satisfying
<code>VectorRange</code>. The stored scalar values will correspond to
every stored scalar value in <code>vector</code> transformed using the
function <code>fn</code>.</p></li>
</ol>
<h3 id="example-1">Example</h3>
<div class="sourceCode" id="cb47"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;grb/grb.hpp&gt;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">**</span> argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>matrix<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> a<span class="op">({</span><span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">});</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>  a<span class="op">[{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">}]</span> <span class="op">=</span> <span class="fl">12.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>  a<span class="op">[{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">}]</span> <span class="op">=</span> <span class="fl">123.2</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>  a<span class="op">[{</span><span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">}]</span> <span class="op">=</span> <span class="fl">8.0</span><span class="bu">f</span><span class="op">;;</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>print<span class="op">(</span>a<span class="op">,</span> <span class="st">&quot;original matrix&quot;</span><span class="op">);</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Transform each scalar value based on its</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// row and column index.</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> idx_view <span class="op">=</span> grb<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(</span>a<span class="op">,</span> <span class="op">[](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> entry<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>                                              <span class="kw">auto</span><span class="op">&amp;&amp;</span> <span class="op">[</span>idx<span class="op">,</span> v<span class="op">]</span> <span class="op">=</span> entry<span class="op">;</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>                                              <span class="kw">auto</span><span class="op">&amp;&amp;</span> <span class="op">[</span>i<span class="op">,</span> j<span class="op">]</span> <span class="op">=</span> idx<span class="op">;</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>                                              <span class="cf">return</span> i <span class="op">+</span> j<span class="op">;</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>                                           <span class="op">});</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>print<span class="op">(</span>idx_view<span class="op">,</span> <span class="st">&quot;index transformed view&quot;</span><span class="op">);</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="grbstructure">grb::structure</h2>
<div class="sourceCode" id="cb48"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange M<span class="op">&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>structure_view<span class="op">&lt;</span>M<span class="op">&gt;</span> structure<span class="op">(</span>M<span class="op">&amp;&amp;</span> matrix<span class="op">);</span>                 <span class="op">(</span><span class="dv">1</span><span class="op">)</span> </span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange V<span class="op">&gt;</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>structure_view<span class="op">&lt;</span>V<span class="op">&gt;</span> structure<span class="op">(</span>V<span class="op">&amp;&amp;</span> vector<span class="op">);</span>                 <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span></code></pre></div>
<h3 id="parameters-31">Parameters</h3>
<p><code>matrix</code> - a GraphBLAS matrix or matrix view</p>
<p><code>vector</code> - a GraphBLAS vector or vector view</p>
<h4 id="type-requirements-4">Type Requirements</h4>
<ul>
<li><p><code>matrix</code> must meet the requirements of
<code>MatrixRange</code></p></li>
<li><p><code>vector</code> must meet the requirements of
<code>VectorRange</code></p></li>
</ul>
<h3 id="return-value-28">Return Value</h3>
<ol type="1">
<li>Returns a view of the matrix</li>
</ol>
<h4 id="possible-implementation">Possible Implementation</h4>
<div class="sourceCode" id="cb49"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> always_true <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span><span class="op">&amp;&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> O<span class="op">&gt;</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> structure_view <span class="op">=</span> grb<span class="op">::</span>transform_view<span class="op">&lt;</span>O<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>always_true<span class="op">)&gt;;</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange M<span class="op">&gt;</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>structure_view<span class="op">&lt;</span>M<span class="op">&gt;</span> structure<span class="op">(</span>M<span class="op">&amp;&amp;</span> matrix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> grb<span class="op">::</span>transform<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>M<span class="op">&gt;(</span>matrix<span class="op">),</span> always_true<span class="op">);</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange V<span class="op">&gt;</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>structure_view<span class="op">&lt;</span>V<span class="op">&gt;</span> structure<span class="op">(</span>V<span class="op">&amp;&amp;</span> vector<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> grb<span class="op">::</span>transform<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>V<span class="op">&gt;(</span>vector<span class="op">),</span> always_true<span class="op">);</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="grbfilter">grb::filter</h2>
<div class="sourceCode" id="cb50"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange M<span class="op">,</span> <span class="kw">typename</span> Fn<span class="op">&gt;</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>filter_view<span class="op">&lt;</span>M<span class="op">&gt;</span> filter<span class="op">(</span>M<span class="op">&amp;&amp;</span> matrix<span class="op">,</span> Fn<span class="op">&amp;&amp;</span> fn<span class="op">);</span>              <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange V<span class="op">,</span> <span class="kw">typename</span> Fn<span class="op">&gt;</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>filter_view<span class="op">&lt;</span>V<span class="op">&gt;</span> filter<span class="op">(</span>V<span class="op">&amp;&amp;</span> vector<span class="op">,</span> Fn<span class="op">&amp;&amp;</span> fn<span class="op">);</span>              <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span></code></pre></div>
<h3 id="parameters-32">Parameters</h3>
<p><code>matrix</code> - a GraphBLAS matrix</p>
<p><code>vector</code> - a GraphBLAS vector</p>
<p><code>fn</code> - a function determining which elements should be
filtered out</p>
<h4 id="type-requirements-5">Type Requirements</h4>
<ul>
<li><p><code>M</code> must meet the requirements of
<code>MaskMatrixRange</code></p></li>
<li><p><code>V</code> must meet the requirements of
<code>MaskVectorRange</code></p></li>
<li><p><code>fn</code> must accept an argument of type
<code>std::ranges::value_type_t&lt;M&gt;</code> (1) or
<code>std::ranges::value_type_t&lt;V&gt;</code> (2) and return a value
of type <code>bool</code>.</p></li>
</ul>
<h3 id="return-value-29">Return Value</h3>
<p>Returns a filtered view of the matrix <code>matrix</code> or vector
<code>vector</code>. The return value fulfills the requirements of
<code>MatrixRange</code> (1) or <code>VectorRange</code> (2) . The
return value has the same shape as the input object, but without
elements for which <code>fn(e)</code> evaluates to false.</p>
<h2 id="grbcomplement">grb::complement</h2>
<div class="sourceCode" id="cb51"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MaskMatrixRange M<span class="op">&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>complement_view<span class="op">&lt;</span>M<span class="op">&gt;</span> complement<span class="op">(</span>M<span class="op">&amp;&amp;</span> mask<span class="op">);</span>                 <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MaskVectorRange V<span class="op">&gt;</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>complement_view<span class="op">&lt;</span>V<span class="op">&gt;</span> complement<span class="op">(</span>V<span class="op">&amp;&amp;</span> mask<span class="op">);</span>                 <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span></code></pre></div>
<h3 id="parameters-33">Parameters</h3>
<p><code>mask</code> - a GraphBLAS mask</p>
<h4 id="type-requirements-6">Type Requirements</h4>
<ul>
<li><p><code>M</code> must meet the requirements of
<code>MaskMatrixRange</code></p></li>
<li><p><code>V</code> must meet the requirements of
<code>MaskVectorRange</code></p></li>
</ul>
<h3 id="return-value-30">Return Value</h3>
<p><em>TODO: Scott, Jose, is this the behavior we want?</em> Returns the
complement view of a matrix or vector mask. At every index in
<code>mask</code> with no stored value or with a scalar value equal to
<code>false</code> when converted to <code>bool</code>, the returned
view has a stored value with the scalar value <code>true</code>. At
every stored value in <code>mask</code> with a scalar value equal to
<code>true</code> when converted to <code>bool</code>, the return view
has no stored value.</p>
<ol type="1">
<li><p>Returns a matrix view satisfying the requirements
<code>MaskMatrixRange</code>.</p></li>
<li><p>Returns a vector view satisfying the requirements
<code>MaskVectorRange</code>.</p></li>
</ol>
<h2 id="grbmask">grb::mask</h2>
<div class="sourceCode" id="cb52"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange Matrix<span class="op">,</span> MaskMatrixRange M<span class="op">&gt;</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>masked_view<span class="op">&lt;</span>Matrix<span class="op">,</span> M<span class="op">&gt;</span> mask<span class="op">(</span>Matrix<span class="op">&amp;&amp;</span> matrix<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask<span class="op">);</span>                 <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange Vector<span class="op">,</span> MaskVectorRange M<span class="op">&gt;</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>masked_view<span class="op">&lt;</span>Vector<span class="op">,</span> M<span class="op">&gt;</span> mask<span class="op">(</span>Vector<span class="op">&amp;&amp;</span> vector<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask<span class="op">);</span>                 <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span></code></pre></div>
<h3 id="parameters-34">Parameters</h3>
<p><code>matrix</code> - a GraphBLAS matrix or vector</p>
<p><code>mask</code> - a GraphBLAS mask with the same shape as
<code>matrix</code> (1) or <code>vector</code> (2)</p>
<h4 id="type-requirements-7">Type Requirements</h4>
<ul>
<li><p><code>Matrix</code> must meet the requirements of
<code>MatrixRange</code></p></li>
<li><p><code>Vector</code> must meet the requirements of
<code>VectorRange</code></p></li>
<li><p><code>M</code> must meet the requirements of
<code>MaskMatrixRange</code> (1) or <code>MaskVectorRange</code>
(2)</p></li>
</ul>
<h3 id="return-value-31">Return Value</h3>
<p>Returns a view of the matrix <code>matrix</code> (1) or vector
<code>vector</code> that has been masked using <code>mask</code>. Any
value in <code>matrix</code> for which <code>mask</code> does not have
an entry at the corresponding location or for which <code>mask</code>
has a value equal to <code>false</code> when converted to
<code>bool</code> will not be visible in the returned mask view.</p>
<ol type="1">
<li>Returns a matrix view satisfying the requirements
<code>MatrixRange</code>. Any values in <code>matrix</code> for which
<code>grb::find(mask, index) == grb::end(mask) || bool(*grb::find(mask, index)) == false</code>
will be masked out of the returned matrix view.</li>
</ol>
<h3 id="exceptions-6">Exceptions</h3>
<p>The exception <code>grb::invalid_argument</code> is thrown if the
<code>mask</code> does not have the same shape as <code>matrix</code>
(1) or <code>vector</code> (2).</p>
<h2 id="grbsubmatrix_view">grb::submatrix_view</h2>
<div class="sourceCode" id="cb53"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange M<span class="op">&gt;</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>submatrix_view<span class="op">&lt;</span>M<span class="op">&gt;</span> submatrix<span class="op">(</span>M<span class="op">&amp;&amp;</span> matrix<span class="op">,</span> grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> rows<span class="op">,</span> grb<span class="op">::</span>index<span class="op">&lt;</span>I<span class="op">&gt;</span> cols<span class="op">);</span></span></code></pre></div>
<h4 id="parameters-35">Parameters</h4>
<p><code>matrix</code> - a GraphBLAS matrix</p>
<p><code>rows</code> - the span of rows in the submatrix view</p>
<p><code>cols</code> - the span of columns in the submatrix view</p>
<h3 id="return-value-32">Return Value</h3>
<p>Returns a view of the submatrix of GraphBLAS matrix
<code>matrix</code> formed by the intersection of rows
<code>rows[0]</code> to <code>rows[1]</code> and columns
<code>cols[0]</code> to <code>cols[1]</code>. The returned matrix range
has shape
<code>grb::min(rows[1], grb::shape(matrix)[0]) - grb::max(rows[0], 0)</code>
by
<code>grb::min(cols[1], grb::shape(matrix)[1]) - grb::max(cols[0], 0)</code>
and contains all stored values for whose index the expression
<code>index[0] &gt;= rows[0] &amp;&amp; index[0] &lt; rows[1] &amp;&amp; index[1] &gt;= cols[0] &amp;&amp; index[1] &lt; cols[1]</code>
holds true.</p>
<h3 id="exceptions-7">Exceptions</h3>
<p>Returns the exception <code>grb::invalid_argument</code> if
<code>rows[0] &gt; rows[1]</code> or
<code>cols[0] &gt; cols[1]</code>.</p>
<h1 id="pre-defined-operators">Pre-Defined Operators</h1>
<p>The GraphBLAS C++ API defines a number of binary and unary operators.
Operators are defined as function objects and typically perform
arithmetic or logical operations like addition, multiplication,
negation, and logical and.</p>
<h4 id="todo-discuss-unary-operators">TODO: Discuss Unary Operators</h4>
<p>They work the same way as binary operators, but are quite a bit
simpler, since there is only one value to operate upon.</p>
<h2 id="binary-operator-template-parameters">Binary Operator Template
Parameters</h2>
<p>GraphBLAS’s binary operators allow flexiblility in terms of whether
all, some, or none of the types are explicitly declared. If one or more
types are not explicitly declared, they are deduced at the callsite
where the operator is invoked. For each binary operator <code>op</code>,
there are three partial specializations defined:</p>
<ol type="1">
<li><code>op&lt;T, U, V&gt;</code>, where the input arguments are
explicitly specified to be <code>T</code> and <code>U</code> and the
return value is <code>V</code>.</li>
<li><code>op&lt;T, U, void&gt;</code>, where the input arguments are
explicitly specified to be <code>T</code> and <code>U</code>, and the
return value is deduced.</li>
<li><code>op&lt;void, void, void&gt;</code>, where the inputs arguments
and return type are all deduced upon invocation.</li>
</ol>
<p>All binary operators have the following default template
parameters:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="kw">typename</span> V <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> op<span class="op">;</span></span></code></pre></div>
<p>This means the user can use a binary operator with zero, one, two, or
three template parameters explicitly specified. The types of the input
arguments and return value will be explicitly defined or reduced
accordingly.</p>
<h4 id="no-types-specified">No Types Specified</h4>
<p>If a user specifies no template parameters when using a binary
operator, the result is a function object in which the input argument
and return value types are all deduced at the callsite.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;grb/grb.hpp&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">**</span> argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// No types are explicitly specified.</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// We can use this operator with values of</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// any types for which an operator+() is defined.</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>plus<span class="op">&lt;&gt;</span> p1<span class="op">;</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>size_t<span class="op"> </span>a <span class="op">=</span> <span class="dv">1024</span><span class="op">;</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>uint8_t<span class="op"> </span>b <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `std::size_t` and `std::uint8_t` deduced as types of input arguments.</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `std::size_t` will be deduced as type of return value.</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// std::size_t + std::uint8_t -&gt; std::size_t</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> c <span class="op">=</span> p1<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="one-type-specified">One Type Specified</h4>
<p>If a user specifies one template parameters when using a binary
operator, the result is a function object in which the the two input
arguments are of the type specified, and the return value type is
deduced.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;grb/grb.hpp&gt;</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">**</span> argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Explicitly specify `int` as the type of both input values.</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Return value type will be deduced as `int`.</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>plus<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> p1<span class="op">;</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a <span class="op">=</span> <span class="dv">1024</span><span class="op">;</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> b <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// int + int -&gt; int</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> c <span class="op">=</span> p1<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="two-types-specified">Two Types Specified</h4>
<p>If a user specifies two template parameters when using a binary
operator, the result is a function object in which the the two input
arguments are of the types specified, and the return value type is
deduced.</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;grb/grb.hpp&gt;</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">**</span> argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Explicitly specify `std::size_t` for the lefthand argument</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// and `std::uint8_t` for the righthand argument.</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Return value type will be deduced as `std::size_t`.</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>plus<span class="op">&lt;</span><span class="bu">std::</span>size_t<span class="op">,</span> <span class="bu">std::</span>uint8_t<span class="op">&gt;</span> p1<span class="op">;</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>size_t<span class="op"> </span>a <span class="op">=</span> <span class="dv">1024</span><span class="op">;</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>uint8_t<span class="op"> </span>b <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// std::size_t + std::uint8_t -&gt; std::size_t</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>size_t<span class="op"> </span>c <span class="op">=</span> p1<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="three-types-specified">Three Types Specified</h4>
<p>If a user specifies all three template parameters when using a binary
operator, both of the input argument types as well as the return value
type of the function are explicitly specified.</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;grb/grb.hpp&gt;</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">**</span> argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Explicitly specify `std::size_t` for the lefthand argument</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// and `std::uint8_t` for the righthand argument.</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Return value type explicitly specified as `int`.</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>plus<span class="op">&lt;</span><span class="bu">std::</span>size_t<span class="op">,</span> <span class="bu">std::</span>uint8_t<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> p1<span class="op">;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>size_t<span class="op"> </span>a <span class="op">=</span> <span class="dv">1024</span><span class="op">;</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>uint8_t<span class="op"> </span>b <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// std::size_t + std::uint8_t -&gt; std::size_t</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>size_t<span class="op"> </span>c <span class="op">=</span>  p1<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="grbplus"><code>grb::plus</code></h2>
<div class="sourceCode" id="cb59"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="kw">typename</span> V <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> plus<span class="op">;</span></span></code></pre></div>
<p><code>grb::plus</code> is a binary operator. It forms a monoid on
arithmetic types.</p>
<h3 id="specializations">Specializations</h3>
<table>
<thead>
<tr class="header">
<th>Specialization</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>plus&lt;void, void, void&gt;</code></td>
<td>deduces argument and return types</td>
</tr>
<tr class="even">
<td><code>plus&lt;T, U, void&gt;</code></td>
<td>deduces return type based on <code>T</code> and <code>U</code></td>
</tr>
</tbody>
</table>
<h3 id="template-parameters-3">Template Parameters</h3>
<p><code>T</code> - Type of the left hand argument of the operator</p>
<p><code>U</code> - Type of the right hand argument of the operator</p>
<p><code>V</code> - Return type of the operator</p>
<h3 id="methods-3">Methods</h3>
<table>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>operator()</code></td>
<td>returns the sum of the two arguments</td>
</tr>
</tbody>
</table>
<h4 id="grbplusoperator"><code>grb::plus::operator()</code></h4>
<div class="sourceCode" id="cb60"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> V <span class="kw">operator</span><span class="op">()(</span> <span class="at">const</span> T<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> rhs <span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Returns the sum of <code>lhs</code> and <code>rhs</code>.</p>
<h4 id="parameters-36">Parameters</h4>
<p><code>lhs</code>, <code>rhs</code> - values to sum</p>
<h4 id="return-value-33">Return Value</h4>
<p>The result of <code>lhs + rhs</code>.</p>
<h4 id="exceptions-8">Exceptions</h4>
<p>May throw exceptions if the underlying <code>operator+()</code>
operation throws exceptions</p>
<h4 id="monoid-traits">Monoid Traits</h4>
<p><code>grb::plus</code> forms a monoid on any arithmetic type
<code>A</code> with the identity value <code>0</code>, as long as
<code>T</code>, <code>U</code>, and <code>V</code> are equal to void or
<code>A</code>.</p>
<h3 id="specialization-details">Specialization Details</h3>
<h4
id="grbplusvoid-void-void"><code>grb::plus&lt;void, void, void&gt;</code></h4>
<div class="sourceCode" id="cb61"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> plus<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::plus</code> with both arguments and return
types deduced.</p>
<h4 id="grbplusoperator-1"><code>grb::plus::operator()</code></h4>
<div class="sourceCode" id="cb62"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>T<span class="op">&amp;&amp;</span> lhs<span class="op">,</span> U<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="at">const</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>lhs<span class="op">)</span> <span class="op">+</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>rhs<span class="op">));</span></span></code></pre></div>
<h4 id="grbplust-u-void"><code>grb::plus&lt;T, U, void&gt;</code></h4>
<div class="sourceCode" id="cb63"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> plus<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::plus</code> with explicit types for the
arguments, but return type deduced.</p>
<h4 id="grbplusoperator-2"><code>grb::plus::operator()</code></h4>
<div class="sourceCode" id="cb64"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>lhs <span class="op">+</span> rhs<span class="op">);</span></span></code></pre></div>
<h2 id="grbmultiplies"><code>grb::multiplies</code></h2>
<div class="sourceCode" id="cb65"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="kw">typename</span> V <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> multiplies<span class="op">;</span></span></code></pre></div>
<p><code>grb::multiplies</code> is a binary operator. It forms a monoid
on arithmetic types.</p>
<h3 id="specializations-1">Specializations</h3>
<table>
<thead>
<tr class="header">
<th>Specialization</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>multiplies&lt;void, void, void&gt;</code></td>
<td>deduces argument and return types</td>
</tr>
<tr class="even">
<td><code>multiplies&lt;T, U, void&gt;</code></td>
<td>deduces return type based on <code>T</code> and <code>U</code></td>
</tr>
</tbody>
</table>
<h3 id="template-parameters-4">Template Parameters</h3>
<p><code>T</code> - Type of the left hand argument of the operator</p>
<p><code>U</code> - Type of the right hand argument of the operator</p>
<p><code>V</code> - Return type of the operator</p>
<h3 id="methods-4">Methods</h3>
<table>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>operator()</code></td>
<td>returns the product of the two arguments</td>
</tr>
</tbody>
</table>
<h4
id="grbmultipliesoperator"><code>grb::multiplies::operator()</code></h4>
<div class="sourceCode" id="cb66"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> V <span class="kw">operator</span><span class="op">()(</span> <span class="at">const</span> T<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> rhs <span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Returns the product of <code>lhs</code> and <code>rhs</code>.</p>
<h4 id="parameters-37">Parameters</h4>
<p><code>lhs</code>, <code>rhs</code> - values to multiply</p>
<h4 id="return-value-34">Return Value</h4>
<p>The result of <code>lhs * rhs</code>.</p>
<h4 id="exceptions-9">Exceptions</h4>
<p>May throw exceptions if the underlying <code>operator*()</code>
operation throws exceptions</p>
<h4 id="monoid-traits-1">Monoid Traits</h4>
<p><code>grb::multiplies</code> forms a monoid on any arithmetic type
<code>A</code> with the identity value <code>1</code>, as long as
<code>T</code>, <code>U</code>, and <code>V</code> are equal to void or
<code>A</code>.</p>
<h4 id="specialization-details-1">Specialization Details</h4>
<h5
id="grbmultipliesvoid-void-void"><code>grb::multiplies&lt;void, void, void&gt;</code></h5>
<div class="sourceCode" id="cb67"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> multiplies<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::multiplies</code> with both arguments and
return types deduced.</p>
<h5
id="grbmultipliesoperator-1"><code>grb::multiplies::operator()</code></h5>
<div class="sourceCode" id="cb68"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>T<span class="op">&amp;&amp;</span> lhs<span class="op">,</span> U<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="at">const</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>lhs<span class="op">)</span> <span class="op">*</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>rhs<span class="op">));</span></span></code></pre></div>
<h5
id="grbmultipliest-u-void"><code>grb::multiplies&lt;T, U, void&gt;</code></h5>
<div class="sourceCode" id="cb69"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> multiplies<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::multiplies</code> with explicit types for the
arguments, but return type deduced.</p>
<h5
id="grbmultipliesoperator-2"><code>grb::multiplies::operator()</code></h5>
<div class="sourceCode" id="cb70"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>lhs <span class="op">*</span> rhs<span class="op">);</span></span></code></pre></div>
<h2 id="grbminus"><code>grb::minus</code></h2>
<div class="sourceCode" id="cb71"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="kw">typename</span> V <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> minus<span class="op">;</span></span></code></pre></div>
<p><code>grb::minus</code> is a binary operator that subtracts two
values.</p>
<h3 id="specializations-2">Specializations</h3>
<table>
<thead>
<tr class="header">
<th>Specialization</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>minus&lt;void, void, void&gt;</code></td>
<td>deduces argument and return types</td>
</tr>
<tr class="even">
<td><code>minus&lt;T, U, void&gt;</code></td>
<td>deduces return type based on <code>T</code> and <code>U</code></td>
</tr>
</tbody>
</table>
<h3 id="template-parameters-5">Template Parameters</h3>
<p><code>T</code> - Type of the left hand argument of the operator</p>
<p><code>U</code> - Type of the right hand argument of the operator</p>
<p><code>V</code> - Return type of the operator</p>
<h3 id="methods-5">Methods</h3>
<table>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>operator()</code></td>
<td>returns the difference of the two arguments</td>
</tr>
</tbody>
</table>
<h4 id="grbminusoperator"><code>grb::minus::operator()</code></h4>
<div class="sourceCode" id="cb72"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> V <span class="kw">operator</span><span class="op">()(</span> <span class="at">const</span> T<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> rhs <span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Returns the difference of <code>lhs</code> and <code>rhs</code>.</p>
<h4 id="parameters-38">Parameters</h4>
<p><code>lhs</code>, <code>rhs</code> - values to subtract</p>
<h4 id="return-value-35">Return Value</h4>
<p>The result of <code>lhs - rhs</code>.</p>
<h4 id="exceptions-10">Exceptions</h4>
<p>May throw exceptions if the underlying <code>operator-()</code>
operation throws exceptions</p>
<h4 id="monoid-traits-2">Monoid Traits</h4>
<p><code>grb::minus</code> does not form a monoid for arithmetic
types.</p>
<h3 id="specialization-details-2">Specialization Details</h3>
<h4
id="grbminusvoid-void-void"><code>grb::minus&lt;void, void, void&gt;</code></h4>
<div class="sourceCode" id="cb73"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> minus<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::minus</code> with both arguments and return
types deduced.</p>
<h4 id="grbminusoperator-1"><code>grb::minus::operator()</code></h4>
<div class="sourceCode" id="cb74"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>T<span class="op">&amp;&amp;</span> lhs<span class="op">,</span> U<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="at">const</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>lhs<span class="op">)</span> <span class="op">-</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>rhs<span class="op">));</span></span></code></pre></div>
<h4 id="grbminust-u-void"><code>grb::minus&lt;T, U, void&gt;</code></h4>
<div class="sourceCode" id="cb75"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> minus<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::minus</code> with explicit types for the
arguments, but return type deduced.</p>
<h4 id="grbminusoperator-2"><code>grb::minus::operator()</code></h4>
<div class="sourceCode" id="cb76"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>lhs <span class="op">-</span> rhs<span class="op">);</span></span></code></pre></div>
<h2 id="grbdivides"><code>grb::divides</code></h2>
<div class="sourceCode" id="cb77"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="kw">typename</span> V <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> divides<span class="op">;</span></span></code></pre></div>
<p><code>grb::divides</code> is a binary operator that divides two
values.</p>
<h3 id="specializations-3">Specializations</h3>
<table>
<thead>
<tr class="header">
<th>Specialization</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>divides&lt;void, void, void&gt;</code></td>
<td>deduces argument and return types</td>
</tr>
<tr class="even">
<td><code>divides&lt;T, U, void&gt;</code></td>
<td>deduces return type based on <code>T</code> and <code>U</code></td>
</tr>
</tbody>
</table>
<h3 id="template-parameters-6">Template Parameters</h3>
<p><code>T</code> - Type of the left hand argument of the operator</p>
<p><code>U</code> - Type of the right hand argument of the operator</p>
<p><code>V</code> - Return type of the operator</p>
<h3 id="methods-6">Methods</h3>
<table>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>operator()</code></td>
<td>returns the difference of the two arguments</td>
</tr>
</tbody>
</table>
<h4 id="grbdividesoperator"><code>grb::divides::operator()</code></h4>
<div class="sourceCode" id="cb78"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> V <span class="kw">operator</span><span class="op">()(</span> <span class="at">const</span> T<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> rhs <span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Returns the difference of <code>lhs</code> and <code>rhs</code>.</p>
<h4 id="parameters-39">Parameters</h4>
<p><code>lhs</code>, <code>rhs</code> - values to divide</p>
<h4 id="return-value-36">Return Value</h4>
<p>The result of <code>lhs / rhs</code>.</p>
<h4 id="exceptions-11">Exceptions</h4>
<p>May throw exceptions if the underlying <code>operator/()</code>
operation throws exceptions</p>
<h4 id="monoid-traits-3">Monoid Traits</h4>
<p><code>grb::divides</code> does not form a monoid for arithmetic
types.</p>
<h3 id="specialization-details-3">Specialization Details</h3>
<h4
id="grbdividesvoid-void-void"><code>grb::divides&lt;void, void, void&gt;</code></h4>
<div class="sourceCode" id="cb79"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> divides<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::divides</code> with both arguments and return
types deduced.</p>
<h4 id="grbdividesoperator-1"><code>grb::divides::operator()</code></h4>
<div class="sourceCode" id="cb80"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>T<span class="op">&amp;&amp;</span> lhs<span class="op">,</span> U<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="at">const</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>lhs<span class="op">)</span> <span class="op">/</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>rhs<span class="op">));</span></span></code></pre></div>
<h4
id="grbdividest-u-void"><code>grb::divides&lt;T, U, void&gt;</code></h4>
<div class="sourceCode" id="cb81"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> divides<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::divides</code> with explicit types for the
arguments, but return type deduced.</p>
<h5 id="grbdividesoperator-2">grb::divides::operator()</h5>
<div class="sourceCode" id="cb82"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>lhs <span class="op">/</span> rhs<span class="op">);</span></span></code></pre></div>
<h2 id="grbmax"><code>grb::max</code></h2>
<div class="sourceCode" id="cb83"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="kw">typename</span> V <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> max<span class="op">;</span></span></code></pre></div>
<p><code>grb::max</code> is a binary operator that returns the larger of
two arguments. When both input arguments have integral types,
<code>std::cmp_less</code> is used for comparison. When one or both
arguments have non-integral types, <code>operator&lt;</code> is used for
comparison. It forms a monoid on arithmetic types.</p>
<h3 id="specializations-4">Specializations</h3>
<table>
<thead>
<tr class="header">
<th>Specialization</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>max&lt;void, void, void&gt;</code></td>
<td>deduces argument and return types</td>
</tr>
<tr class="even">
<td><code>max&lt;T, U, void&gt;</code></td>
<td>deduces return type based on <code>T</code> and <code>U</code></td>
</tr>
</tbody>
</table>
<h3 id="template-parameters-7">Template Parameters</h3>
<p><code>T</code> - Type of the left hand argument of the operator</p>
<p><code>U</code> - Type of the right hand argument of the operator</p>
<p><code>V</code> - Return type of the operator</p>
<h3 id="methods-7">Methods</h3>
<table>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>operator()</code></td>
<td>returns the larger of two arguments</td>
</tr>
</tbody>
</table>
<h4 id="grbmaxoperator"><code>grb::max::operator()</code></h4>
<div class="sourceCode" id="cb84"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> V <span class="kw">operator</span><span class="op">()(</span> <span class="at">const</span> T<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> rhs <span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Returns the larger of <code>lhs</code> and <code>rhs</code>.</p>
<h4 id="parameters-40">Parameters</h4>
<p><code>lhs</code>, <code>rhs</code> - values to take the max of</p>
<h4 id="return-value-37">Return Value</h4>
<p>The larger of <code>lhs</code> and <code>rhs</code>.</p>
<h4 id="exceptions-12">Exceptions</h4>
<p>May throw exceptions if the underlying <code>operator&lt;()</code>
operation throws exceptions</p>
<h4 id="monoid-traits-4">Monoid Traits</h4>
<p><code>grb::max</code> forms a monoid on any arithmetic type
<code>A</code> with the identity value
<code>std::min(std::numeric_limits&lt;A&gt;::lowest(), -std::numeric_limits&lt;A&gt;::infinity())</code>,
as long as <code>T</code>, <code>U</code>, and <code>V</code> are equal
to void or <code>A</code>.</p>
<h3 id="specialization-details-4">Specialization Details</h3>
<h4
id="grbmaxvoid-void-void"><code>grb::max&lt;void, void, void&gt;</code></h4>
<div class="sourceCode" id="cb85"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> max<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::max</code> with both arguments and return types
deduced.</p>
<h4 id="grbmaxoperator-1"><code>grb::max::operator()</code></h4>
<div class="sourceCode" id="cb86"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>integral<span class="op"> </span>T<span class="op">,</span> <span class="bu">std::</span>integral<span class="op"> </span>U<span class="op">&gt;</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> b<span class="op">)</span> <span class="at">const</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>cmp_less<span class="op">(</span><span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>max<span class="op">(),</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>U<span class="op">&gt;::</span>max<span class="op">()),</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>      U<span class="op">,</span> T</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>     <span class="op">&gt;;</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> b<span class="op">)</span> <span class="at">const</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>max<span class="op">()</span> <span class="op">&lt;</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>U<span class="op">&gt;::</span>max<span class="op">(),</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>      U<span class="op">,</span> T</span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>     <span class="op">&gt;</span></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span><span class="op">(!(</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>U<span class="op">&gt;));</span></span></code></pre></div>
<h4 id="grbmaxt-u-void"><code>grb::max&lt;T, U, void&gt;</code></h4>
<div class="sourceCode" id="cb87"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> max<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::max</code> with explicit types for the
arguments, but return type deduced.</p>
<h4 id="grbmaxoperator-2"><code>grb::max::operator()</code></h4>
<div class="sourceCode" id="cb88"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> b<span class="op">)</span> <span class="at">const</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>cmp_less<span class="op">(</span><span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>max<span class="op">(),</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>U<span class="op">&gt;::</span>max<span class="op">()),</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>      U<span class="op">,</span> T</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">&gt;;</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> b<span class="op">)</span> <span class="at">const</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>max<span class="op">()</span> <span class="op">&lt;</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>U<span class="op">&gt;::</span>max<span class="op">(),</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>      U<span class="op">,</span> T</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>     <span class="op">&gt;</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span><span class="op">(!(</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>U<span class="op">&gt;));</span></span></code></pre></div>
<h2 id="grbmin"><code>grb::min</code></h2>
<div class="sourceCode" id="cb89"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="kw">typename</span> V <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> min<span class="op">;</span></span></code></pre></div>
<p><code>grb::min</code> is a binary operator that returns the smaller
of two arguments. using <code>operator&lt;</code> for comparison. When
both input arguments have integral types, <code>std::cmp_less</code> is
used for comparison. When one or both arguments have non-integral types,
<code>operator&lt;</code> is used for comparison. It forms a monoid on
arithmetic types.</p>
<h3 id="specializations-5">Specializations</h3>
<table>
<thead>
<tr class="header">
<th>Specialization</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>min&lt;void, void, void&gt;</code></td>
<td>deduces argument and return types</td>
</tr>
<tr class="even">
<td><code>min&lt;T, U, void&gt;</code></td>
<td>deduces return type based on <code>T</code> and <code>U</code></td>
</tr>
</tbody>
</table>
<h3 id="template-parameters-8">Template Parameters</h3>
<p><code>T</code> - Type of the left hand argument of the operator</p>
<p><code>U</code> - Type of the right hand argument of the operator</p>
<p><code>V</code> - Return type of the operator</p>
<h3 id="methods-8">Methods</h3>
<table>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>operator()</code></td>
<td>returns the smaller of two arguments</td>
</tr>
</tbody>
</table>
<h4 id="grbminoperator"><code>grb::min::operator()</code></h4>
<div class="sourceCode" id="cb90"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> V <span class="kw">operator</span><span class="op">()(</span> <span class="at">const</span> T<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> rhs <span class="op">)</span> <span class="at">const</span><span class="op">;</span></span></code></pre></div>
<p>Returns the smaller of <code>lhs</code> and <code>rhs</code>.</p>
<h4 id="parameters-41">Parameters</h4>
<p><code>lhs</code>, <code>rhs</code> - values to take the min of</p>
<h4 id="return-value-38">Return Value</h4>
<p>The smaller of <code>lhs</code> and <code>rhs</code>.</p>
<h4 id="exceptions-13">Exceptions</h4>
<p>May throw exceptions if the underlying <code>operator&lt;()</code>
operation throws exceptions</p>
<h4 id="monoid-traits-5">Monoid Traits</h4>
<p><code>grb::min</code> forms a monoid on any arithmetic type
<code>A</code> with the identity value
<code>std::max(std::numeric_limits&lt;A&gt;::max(), std::numeric_limits&lt;A&gt;::infinity())</code>,
as long as <code>T</code>, <code>U</code>, and <code>V</code> are equal
to void or <code>A</code>.</p>
<h3 id="specialization-details-5">Specialization Details</h3>
<h4
id="grbminvoid-void-void"><code>grb::min&lt;void, void, void&gt;</code></h4>
<div class="sourceCode" id="cb91"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> min<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::min</code> with both arguments and return types
deduced.</p>
<h4 id="grbminoperator-1"><code>grb::min::operator()</code></h4>
<div class="sourceCode" id="cb92"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>integral<span class="op"> </span>T<span class="op">,</span> <span class="bu">std::</span>integral<span class="op"> </span>U<span class="op">&gt;</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> b<span class="op">)</span> <span class="at">const</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>       <span class="bu">std::</span>cmp_less<span class="op">(</span><span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>U<span class="op">&gt;::</span>lowest<span class="op">(),</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>                     <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>lowest<span class="op">()),</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>       U<span class="op">,</span> T</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>     <span class="op">&gt;;</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> b<span class="op">)</span> <span class="at">const</span></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>       <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>U<span class="op">&gt;::</span>lowest<span class="op">()</span> <span class="op">&lt;</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>lowest<span class="op">(),</span></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>       U<span class="op">,</span> T</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a>     <span class="op">&gt;</span></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span><span class="op">(!(</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>U<span class="op">&gt;));</span></span></code></pre></div>
<h4 id="grbmint-u-void"><code>grb::min&lt;T, U, void&gt;</code></h4>
<div class="sourceCode" id="cb93"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> min<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span></code></pre></div>
<p>Version of <code>grb::min</code> with explicit types for the
arguments, but return type deduced.</p>
<h4 id="grbminoperator-2"><code>grb::min::operator()</code></h4>
<div class="sourceCode" id="cb94"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> b<span class="op">)</span> <span class="at">const</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>       <span class="bu">std::</span>cmp_less<span class="op">(</span><span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>U<span class="op">&gt;::</span>lowest<span class="op">(),</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>                     <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>lowest<span class="op">()),</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>       U<span class="op">,</span> T</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">&gt;;</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> T<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> U<span class="op">&amp;</span> b<span class="op">)</span> <span class="at">const</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>       <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>U<span class="op">&gt;::</span>lowest<span class="op">()</span> <span class="op">&lt;</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>lowest<span class="op">(),</span></span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>       U<span class="op">,</span> T</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a>     <span class="op">&gt;</span></span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span><span class="op">(!(</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>U<span class="op">&gt;));</span></span></code></pre></div>
<h1 id="utilities">Utilities</h1>
<p><em>TODO: need “disablers” for all these CPOs. Also, “converted to
its decayed type?”</em></p>
<h2 id="grbget"><code>grb::get</code></h2>
<div class="sourceCode" id="cb95"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="co">/* unspecified */</span> get <span class="op">=</span> <span class="co">/* unspecified */</span><span class="op">;</span></span></code></pre></div>
<h4 id="call-signature-2">Call Signature</h4>
<div class="sourceCode" id="cb96"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>size_t<span class="op"> </span>I<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span> <span class="co">/* see below */</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="bu">std::</span>tuple_element<span class="op">&lt;</span>I<span class="op">,</span> T<span class="op">&gt;</span> get<span class="op">(</span>T<span class="op">&amp;&amp;</span> tuple<span class="op">);</span></span></code></pre></div>
<p><em>TODO: we need someone who understands CPOs a little better to
understand this.</em></p>
<p>Returns the <code>I'th</code> element stored in the tuple-like object
<code>tuple</code>.</p>
<p>A call to <code>grb::get</code> is expression-equivalent to:</p>
<ol type="1">
<li><code>tuple.get&lt;I&gt;()</code>, if that expression is valid.</li>
<li>Otherwise, any calls to <code>get(tuple)</code> found through
argument-dependent lookup.</li>
<li>Otherwise, <code>std::get&lt;I&gt;(tuple)</code>.</li>
</ol>
<p>In all other cases, a call to <code>grb::get</code> is
ill-formed.</p>
<h2 id="grbsize"><code>grb::size</code></h2>
<div class="sourceCode" id="cb97"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="co">/* unspecified */</span> size <span class="op">=</span> <span class="bu">std::</span>ranges<span class="bu">::</span>size<span class="op">;</span></span></code></pre></div>
<h4 id="call-signature-3">Call Signature</h4>
<div class="sourceCode" id="cb98"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> size<span class="op">(</span>T<span class="op">&amp;&amp;</span> t<span class="op">);</span></span></code></pre></div>
<p>Returns the number of stored values in a GraphBLAS matrix, vector, or
other range. Whenever <code>grb::size(e)</code> is valid for an
expression <code>e</code>, the return type is integer-like.</p>
<p>A call to <code>grb::size(t)</code> is expression-equivalent to:</p>
<ol type="1">
<li><code>t.size()</code>, if that expression is valid.</li>
<li>Otherwise, any calls to <code>size(t)</code>, found through
argument-dependent lookup.</li>
</ol>
<p>In all other cases, a call to <code>grb::size</code> is
ill-formed.</p>
<h2 id="grbshape"><code>grb::shape</code></h2>
<div class="sourceCode" id="cb99"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="co">/* unspecified */</span> shape <span class="op">=</span> <span class="co">/* unspecified */</span><span class="op">;</span></span></code></pre></div>
<h4 id="call-signature-4">Call Signature</h4>
<div class="sourceCode" id="cb100"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span> <span class="co">/* see below */</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> shape<span class="op">(</span>T<span class="op">&amp;&amp;</span> t<span class="op">);</span></span></code></pre></div>
<p>Returns the shape of a GraphBLAS object. If <code>T</code> fulfills
the requirements of <code>MatrixRange</code>, then the return type will
be a tuple-like type storing two integer-like values, fulfilling the
requirements of <code>TupleLike&lt;I, I&gt;</code>, where <code>I</code>
is the index type of <code>T</code>. If <code>T</code> fulfills the
requirements of <code>VectorRange</code>, then the return type will be
<code>I</code>, where <code>I</code> is the index type of
<code>T</code>.</p>
<p>A call to <code>grb::shape</code> is expression-equivalent to:</p>
<ol type="1">
<li><code>t.shape()</code> if that expression is valid.</li>
<li>Otherwise, <code>shape(t)</code>, if that expression is valid,
including any declarations of <code>shape</code> found through
argument-dependent lookup.</li>
</ol>
<p>In all other cases, a call to <code>grb::shape</code> is
ill-formed.</p>
<h2 id="grbfind"><code>grb::find</code></h2>
<div class="sourceCode" id="cb101"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="co">/* unspecified */</span> find <span class="op">=</span> <span class="co">/* unspecified */</span><span class="op">;</span></span></code></pre></div>
<h4 id="call-signature-5">Call Signature</h4>
<div class="sourceCode" id="cb102"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> R<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span> <span class="co">/* see below */</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> find<span class="op">(</span>R<span class="op">&amp;&amp;</span> r<span class="op">,</span> T<span class="op">&amp;&amp;</span> t<span class="op">);</span></span></code></pre></div>
<p>Return an iterator to the stored value in the GraphBLAS matrix or
vector <code>r</code> at index location <code>t</code>.</p>
<p>A call to <code>grb::find</code> is expression-equivalent to:</p>
<ol type="1">
<li><code>r.find(t)</code> if that expression is valid.</li>
<li>Otherwise, any calls to <code>find(r, t)</code> found through
argument-dependent lookup.</li>
<li>Otherwise, any calls to <code>std::find(r, t)</code>, if that
expression is valid.</li>
</ol>
<p>In all other cases, a call to <code>grb::find</code> is
ill-formed.</p>
<h2 id="grbinsert"><code>grb::insert</code></h2>
<div class="sourceCode" id="cb103"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="co">/* unspecified */</span> insert <span class="op">=</span> <span class="co">/* unspecified */</span><span class="op">;</span></span></code></pre></div>
<h4 id="call-signature-6">Call Signature</h4>
<div class="sourceCode" id="cb104"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> R<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span> <span class="co">/* see below */</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> insert<span class="op">(</span>R<span class="op">&amp;&amp;</span> r<span class="op">,</span> T<span class="op">&amp;&amp;</span> t<span class="op">);</span></span></code></pre></div>
<p>Attempt to insert the value <code>t</code> into the GraphBLAS matrix
or vector <code>r</code>.</p>
<p>A call to <code>grb::insert</code> is expression-equivalent to:</p>
<ol type="1">
<li><code>r.insert(t)</code> if that expression is valid.</li>
<li>Otherwise, any calls to <code>insert(r, t)</code> found through
argument-dependent lookup.</li>
</ol>
<h2 id="scalar_result_type_t"><code>scalar_result_type_t</code></h2>
<div class="sourceCode" id="cb105"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> B<span class="op">,</span> <span class="kw">typename</span> Combine<span class="op">&gt;</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">scalar_result_type_t</span> <span class="op">=</span> <span class="bu">std::</span>declval<span class="op">&lt;</span>Combine<span class="op">&gt;()(</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>                                <span class="bu">std::</span>declval<span class="op">&lt;</span><span class="dt">scalar_type_t</span><span class="op">&lt;</span>A<span class="op">&gt;&gt;(),</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>                                <span class="bu">std::</span>declval<span class="op">&lt;</span><span class="dt">scalar_type_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;());</span></span></code></pre></div>
<p>The type of the scalar elements produced by combining GraphBLAS
objects of type <code>A</code> and <code>B</code> elementwise using a
binary operator of type <code>Combine</code>.</p>
<h2 id="multiply_result_t"><code>multiply_result_t</code></h2>
<div class="sourceCode" id="cb106"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> B<span class="op">,</span> <span class="kw">typename</span> Reduce<span class="op">,</span> <span class="kw">typename</span> Combine<span class="op">,</span> <span class="kw">typename</span> Mask<span class="op">&gt;</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">multiply_result_t</span> <span class="op">=</span> <span class="co">/* undefined */</span><span class="op">;</span></span></code></pre></div>
<p>The type returned when multiply is called on GraphBLAS matrix or
vector ranges of type <code>A</code> and <code>B</code> using binary
operators <code>Reduce</code> and <code>Combine</code> with mask
<code>Mask</code>.</p>
<p>The scalar type of the returned matrix will be
<code>combine_result_t&lt;A, B, Combine&gt;</code>, and the index type
will be <code>grb::container_index_t&lt;A&gt;</code> or
<code>grb::container_index_t&lt;B&gt;</code>, whichever is able to store
the larger value.</p>
<h2 id="combine_result_t"><code>combine_result_t</code></h2>
<div class="sourceCode" id="cb107"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> B<span class="op">,</span> <span class="kw">typename</span> Combine<span class="op">&gt;</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">combine_result_t</span> <span class="op">=</span> <span class="bu">std::</span>invoke_result_t<span class="op">&lt;</span>Combine<span class="op">,</span> A<span class="op">,</span> B<span class="op">&gt;;</span></span></code></pre></div>
<p>The type returned when the binary operator <code>Combine</code> is
called with an element of the scalar type of <code>A</code> as the first
argument and an element of the scalar type of <code>B</code> as the
second argument. <code>A</code> and <code>B</code> must be GraphBLAS
matrix or vector objects.</p>
<h2 id="ewise_union_result_t"><code>ewise_union_result_t</code></h2>
<div class="sourceCode" id="cb108"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> B<span class="op">,</span> <span class="kw">typename</span> Combine<span class="op">,</span> <span class="kw">typename</span> Mask<span class="op">&gt;</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">ewise_union_result_t</span> <span class="op">=</span> <span class="co">/* undefined */</span><span class="op">;</span></span></code></pre></div>
<p>The type returned when <code>ewise_union</code> is called on the
GraphBLAS matrix or vector ranges of type <code>A</code> and
<code>B</code> using the binary operator <code>Combine</code>.</p>
<h2
id="ewise_intersection_result_t"><code>ewise_intersection_result_t</code></h2>
<div class="sourceCode" id="cb109"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> A<span class="op">,</span> <span class="kw">typename</span> B<span class="op">,</span> <span class="kw">typename</span> Combine<span class="op">,</span> <span class="kw">typename</span> Mask<span class="op">&gt;</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">ewise_intersection_result_t</span> <span class="op">=</span> <span class="co">/* undefined */</span><span class="op">;</span></span></code></pre></div>
<p>The type returned when <code>ewise_intersection</code> is called on
the GraphBLAS matrix or vector ranges of type <code>A</code> and
<code>B</code> using the binary operator <code>Combine</code>.</p>
<h2 id="read_matrix"><code>read_matrix</code></h2>
<div class="sourceCode" id="cb110"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>integral<span class="op"> </span>I <span class="op">=</span> <span class="bu">std::</span>size_t<span class="op">,</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>          <span class="kw">typename</span> Hint <span class="op">=</span> grb<span class="op">::</span>sparse<span class="op">,</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">typename</span> Allocator <span class="op">=</span> <span class="bu">std::</span>allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>grb<span class="op">::</span>matrix<span class="op">&lt;</span>T<span class="op">,</span> I<span class="op">,</span> Hint<span class="op">,</span> Allocator<span class="op">&gt;</span></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>read_matrix<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>file_path<span class="op">);</span></span></code></pre></div>
<p>Constructs a new GraphBLAS matrix based on the contents of a
file.</p>
<h2 id="template-parameters-9">Template Parameters</h2>
<p><code>T</code> - type of scalar values stored in matrix</p>
<p><code>I</code> - type of matrix indices</p>
<p><code>Hint</code> - compile-time hint for backend storage format.</p>
<p><code>Allocator</code> - allocator type</p>
<h3 id="parameters-42">Parameters</h3>
<p><code>file_path</code> - string holding the file path of the matrix
to be read</p>
<h3 id="return-value-39">Return Value</h3>
<p>Returns a GraphBLAS matrix whose dimensions and contents correspond
to the file located at <code>file_path</code>.</p>
<h3 id="complexity-32">Complexity</h3>
<p>Complexity is implementation-defined.</p>
<h3 id="exceptions-14">Exceptions</h3>
<ul>
<li>If the file at <code>file_path</code> cannot be read, the exception
<code>grb::matrix_io::file_error</code> is thrown.</li>
<li>If the file at <code>file_path</code> is recognized as an
unsupported format, the exception
<code>grb::matrix_io::unsupported_file_format</code> is thrown.</li>
<li>Calls to <code>Allocator::allocate</code> may throw.</li>
</ul>
<h3 id="notes">Notes</h3>
<p>GraphBLAS implementations must define the file formats that they
support. Implementations are strongly encouraged to support the
MatrixMarket format.</p>
<h3 id="example-2">Example</h3>
<h1 id="concepts-1">Concepts</h1>
<h2 id="binary-operator">Binary Operator</h2>
<p>Binary operators are function objects that are invocable with two
arguments, returning a single value. Binary operators can be callables
defined by a GraphBLAS library, the C++ Standard Library, or application
developers. Binary operators may be callable with a variety of different
types, or only with elements of a single type. We say a binary operator
is valid for a particular operation <code>T x U -&gt; V</code> if it is
callable with arguments of type <code>T</code> and <code>U</code> and
returns a value convertible to type <code>V</code>.</p>
<h3 id="requirements">Requirements</h3>
<ol type="1">
<li>Callable of type <code>Fn</code> can be invoked with two arguments
of type <code>T</code> and <code>U</code>.</li>
<li>The return value is convertible to type <code>V</code>.</li>
</ol>
<h4 id="concept">Concept</h4>
<div class="sourceCode" id="cb111"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Fn<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="kw">typename</span> V <span class="op">=</span> grb<span class="op">::</span>any<span class="op">&gt;</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> BinaryOperator <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>Fn fn<span class="op">,</span> T t<span class="op">,</span> U u<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>                           <span class="op">{</span>fn<span class="op">(</span>t<span class="op">,</span> u<span class="op">)}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>convertible_to<span class="op">&lt;</span>V<span class="op">&gt;;</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>                         <span class="op">};</span></span></code></pre></div>
<h3 id="remarks">Remarks</h3>
<p>The last two arguments are defaulted unless explicit template
parameters are provided. The second parameter to the concept,
<code>U</code>, which is the right-hand side input to the binary
operator, defaults to <code>T</code>. The final parameter,
<code>V</code>, which represents the output of the binary operator,
defaults to <code>grb::any</code>, meaning that the return value may
have any type.</p>
<h3 id="example-3">Example</h3>
<div class="sourceCode" id="cb112"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Constrain `Fn` to require a binary operator that accepts two integers</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="co">// as arguments and returns a value of any type.</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>BinaryOperator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> Fn<span class="op">&gt;</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> apply<span class="op">(</span>Fn<span class="op">&amp;&amp;</span> fn<span class="op">,</span> <span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> fn<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a><span class="co">// The following code will result in an error, since the function passed</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a><span class="co">// does not fulfill the BinaryOperator&lt;int&gt; requirement, as it cannot accept</span></span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a><span class="co">// integers.</span></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> test<span class="op">()</span> <span class="op">{</span></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> fn <span class="op">=</span> <span class="op">[](</span><span class="bu">std::</span>string<span class="op"> </span>a<span class="op">,</span> <span class="bu">std::</span>string<span class="op"> </span>b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a<span class="op">.</span>size<span class="op">()</span> <span class="op">+</span> b<span class="op">.</span>size<span class="op">();</span> <span class="op">};</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>  apply<span class="op">(</span>fn<span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">13</span><span class="op">);</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="monoid">Monoid</h2>
<p><em>GraphBLAS monoids</em> are commutative monoids. Throughout this
specification, they are referred to simply as monoids. They are binary
operators that have special properties when applied to elements of some
type <code>T</code>. We say that a function object <code>Fn</code> forms
on a monoid on type <code>T</code> if the following requirements are
met.</p>
<h3 id="requirements-1">Requirements</h3>
<ol type="1">
<li>Callable of type <code>Fn</code> fulfills the concept
<code>BinaryOperator&lt;T, T, T&gt;</code> for some type
<code>T</code>.</li>
<li>The operation is associative and commutative for type
<code>T</code>.</li>
<li>The operation has an identity element for type <code>T</code>,
accessible using
<code>grb::monoid_traits&lt;Fn, T&gt;::identity()</code>.</li>
</ol>
<h4 id="concept-1">Concept</h4>
<div class="sourceCode" id="cb113"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Fn<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> Monoid <span class="op">=</span> BinaryOperator<span class="op">&lt;</span>Fn<span class="op">,</span> T<span class="op">,</span> T<span class="op">,</span> T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">requires</span> <span class="op">{</span> <span class="op">{</span>grb<span class="op">::</span>monoid_traits<span class="op">&lt;</span>Fn<span class="op">,</span> T<span class="op">&gt;::</span>identity<span class="op">()}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>T<span class="op">&gt;;</span> <span class="op">};</span></span></code></pre></div>
<h2 id="tuple-like-type">Tuple-Like Type</h2>
<p>Tuple-like types are types that, similar to instantiations of
<code>std::tuple</code> or <code>std::pair</code>, store multiple
values. The number of values stored in the tuple-like type, as well as
the type of each value, are known at compile time. We say that a type
<code>T</code> is tuple-like for the parameter pack of types
<code>Types</code> if it fulfills the following requirements.</p>
<h3 id="requirements-2">Requirements</h3>
<ol type="1">
<li>The tuple <code>T</code> has a size accessible using template
<code>std::tuple_size</code> whose type is equal to
<code>std::size_t</code> and whose value is equal to
<code>sizeof...(Types)</code>.</li>
<li>The type of each stored value in the tuple <code>T</code> is
accessible using <code>std::tuple_element</code>, with the N’th stored
value equal to the N’th type in <code>Types</code>.</li>
<li>Each stored value in <code>T</code> is accessible using the
customization point object <code>grb::get</code>, which will invoke
either the method <code>get()</code> if it is present in the tuple type
<code>T</code> or <code>std::get()</code>. The type of the return value
for the N’th element must be convertible to the N’th element of
<code>Types</code>.</li>
</ol>
<h4 id="concept-2">Concept</h4>
<p>_TODO: this concept could refactored to be a bit more elegant.</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="bu">std::</span>size_t<span class="op"> </span>I<span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> grb<span class="op">::</span>any<span class="op">&gt;</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> TupleElementGettable <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>T tuple<span class="op">)</span> <span class="op">{</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>                                 <span class="op">{</span>grb<span class="op">::</span>get<span class="op">&lt;</span>I<span class="op">&gt;(</span>tuple<span class="op">)}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>convertible_to<span class="op">&lt;</span>U<span class="op">&gt;;</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>                               <span class="op">};</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> TupleLike <span class="op">=</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span> <span class="op">{</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> <span class="bu">std::</span>tuple_size<span class="op">&lt;</span><span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span>T<span class="op">&gt;&gt;::</span>type<span class="op">;</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span><span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>tuple_size_v<span class="op">&lt;</span><span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span>T<span class="op">&gt;&gt;)&gt;,</span> <span class="bu">std::</span>size_t<span class="op">&gt;;</span></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="op">&amp;&amp;</span></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">sizeof</span><span class="op">...(</span>Args<span class="op">)</span> <span class="op">==</span> <span class="bu">std::</span>tuple_size_v<span class="op">&lt;</span><span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">[]&lt;</span><span class="bu">std::</span>size_t<span class="op">...</span> I<span class="op">&gt;(</span><span class="bu">std::</span>index_sequence<span class="op">&lt;</span>I<span class="op">...&gt;)</span> <span class="op">{</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>TupleElementGettable<span class="op">&lt;</span>T<span class="op">,</span> I<span class="op">,</span> Args<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="op">...);</span></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}(</span><span class="bu">std::</span>make_index_sequence<span class="op">&lt;</span><span class="bu">std::</span>tuple_size_v<span class="op">&lt;</span><span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span>T<span class="op">&gt;&gt;&gt;());</span></span></code></pre></div>
<h3 id="example-4">Example</h3>
<div class="sourceCode" id="cb115"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The Concept `TupleLike&lt;int, int, float&gt;` constraints `T`</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="co">// to be a tuple-like type storing int, int, float.</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span>TupleLike<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">float</span><span class="op">&gt;</span> T<span class="op">&gt;</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_tuple<span class="op">(</span>T<span class="op">&amp;&amp;</span> tuple<span class="op">)</span> <span class="op">{</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span><span class="op">&amp;&amp;</span> <span class="op">[</span>i<span class="op">,</span> j<span class="op">,</span> v<span class="op">]</span> <span class="op">=</span> tuple<span class="op">;</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">, </span><span class="sc">%d</span><span class="st">, </span><span class="sc">%f\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">,</span> v<span class="op">);</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="matrix-entry">Matrix Entry</h2>
<p>Matrix entries represent entries in a GraphBLAS matrix, which include
both a tuple-like index storing the row and column index of the stored
scalar value, as well as the scalar value itself. We say that a type
<code>Entry</code> is a valid matrix entry for the scalar type
<code>T</code> and index type <code>I</code> if the following
requirements are met.</p>
<h3 id="requirements-3">Requirements</h3>
<ol type="1">
<li><code>Entry</code> is a tuple-like type with a size of 2.</li>
<li>The first element stored in the tuple-like type <code>Entry</code>
is a tuple-like type fulfilling <code>TupleLike&lt;I, I&gt;</code>,
storing the row and column index of the matrix entry.</li>
<li>The second element stored in the tuple-like type <code>Entry</code>
holds the matrix entry’s scalar value, and is convertible to
<code>T</code>.</li>
</ol>
<h4 id="concept-3">Concept</h4>
<div class="sourceCode" id="cb116"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Entry<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> I<span class="op">&gt;</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> MatrixEntry <span class="op">=</span> TupleLike<span class="op">&lt;</span>Entry<span class="op">,</span> grb<span class="op">::</span>any<span class="op">,</span> grb<span class="op">::</span>any<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">requires</span><span class="op">(</span>Entry entry<span class="op">)</span> <span class="op">{</span> <span class="op">{</span>grb<span class="op">::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>entry<span class="op">)}</span> <span class="op">-&gt;</span> TupleLike<span class="op">&lt;</span>I<span class="op">,</span> I<span class="op">&gt;;</span> <span class="op">}</span> <span class="op">&amp;&amp;</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">requires</span><span class="op">(</span>Entry entry<span class="op">)</span> <span class="op">{</span> <span class="op">{</span>grb<span class="op">::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>entry<span class="op">)}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>convertible_to<span class="op">&lt;</span>T<span class="op">&gt;;</span> <span class="op">};</span></span></code></pre></div>
<h2 id="mutable-matrix-entry">Mutable Matrix Entry</h2>
<p>A mutable matrix entry is an entry in a matrix that fulfills all the
requirements of matrix entry, but whose stored scalar value can be
mutated by assigning to some value of type <code>U</code>. We say that a
matrix entry <code>Entry</code> is a mutable matrix entry for scalar
type <code>T</code>, index type <code>I</code>, and output type
<code>U</code>, if it fulfills all the requirements of matrix entry as
well as the following requirements.</p>
<h3 id="requirements-4">Requirements</h3>
<ol type="1">
<li>The second element of the tuple <code>Entry</code>, representing the
scalar value, is assignable to elements of type <code>U</code>.</li>
</ol>
<h4 id="concept-4">Concept</h4>
<div class="sourceCode" id="cb117"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Entry<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> I<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> MutableMatrixEntry <span class="op">=</span> MatrixEntry<span class="op">&lt;</span>Entry<span class="op">,</span> T<span class="op">,</span> I<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>                             <span class="bu">std::</span>is_assignable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>Entry<span class="op">&gt;())),</span> U<span class="op">&gt;;</span></span></code></pre></div>
<h2 id="matrix-range">Matrix Range</h2>
<p>A matrix in GraphBLAS consists of a range of values distributed over
a two-dimensional domain. In addition to <a
href="#grb::matrix"><code>grb::matrix</code></a>, which directly stores
a collection of values, there are other types, such as views, that
fulfill the same interface. We say that a type <code>M</code> is a
matrix range if the following requirements are met.</p>
<h3 id="requirements-5">Requirements</h3>
<ol type="1">
<li><code>M</code> has a scalar type of the stored values, accessible
with <code>grb::matrix_scalar_t&lt;M&gt;</code></li>
<li><code>M</code> has an index type used to reference the indices of
the stored values, accessible with
<code>grb::matrix_index_t&lt;M&gt;</code>.</li>
<li><code>M</code> is a range with a value type that represents a matrix
tuple, containing both the index and scalar value for each stored
value.</li>
<li><code>M</code> has a shape, which is a tuple-like object of size
two, holding the number of rows and the number of columns, accessible by
invoking the method <code>shape()</code> on an object of type
<code>M</code>.</li>
<li><code>M</code> has a method <code>find()</code> that takes an index
tuple and returns an iterator.</li>
</ol>
<h4 id="concept-5">Concept</h4>
<div class="sourceCode" id="cb118"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> M<span class="op">&gt;</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> MatrixRange <span class="op">=</span> <span class="bu">std::</span>ranges<span class="bu">::</span>sized_range<span class="op">&lt;</span>M<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(</span>M matrix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>M<span class="op">&gt;;</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> grb<span class="op">::</span><span class="dt">matrix_index_t</span><span class="op">&lt;</span>M<span class="op">&gt;;</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="bu">std::</span>declval<span class="op">&lt;</span><span class="bu">std::</span>ranges<span class="bu">::</span>range_value_t<span class="op">&lt;</span><span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span>M<span class="op">&gt;&gt;&gt;()}</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">-&gt;</span> MatrixEntry<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>M<span class="op">&gt;,</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>                     grb<span class="op">::</span><span class="dt">matrix_index_t</span><span class="op">&lt;</span>M<span class="op">&gt;&gt;;</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>grb<span class="op">::</span>shape<span class="op">(</span>matrix<span class="op">)}</span> <span class="op">-&gt;</span> Tuplelike<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_index_t</span><span class="op">&lt;</span>M<span class="op">&gt;,</span></span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>                                  grb<span class="op">::</span><span class="dt">matrix_index_t</span><span class="op">&lt;</span>M<span class="op">&gt;&gt;;</span></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>grb<span class="op">::</span>find<span class="op">(</span>matrix<span class="op">,</span> <span class="op">{</span>grb<span class="op">::</span><span class="dt">matrix_index_t</span><span class="op">&lt;</span>M<span class="op">&gt;{},</span> grb<span class="op">::</span><span class="dt">matrix_index_t</span><span class="op">&lt;</span>M<span class="op">&gt;{}})}</span></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>                 <span class="op">-&gt;</span> <span class="bu">std::</span>convertible_to<span class="op">&lt;</span><span class="bu">std::</span>ranges<span class="bu">::</span>iterator_t<span class="op">&lt;</span>M<span class="op">&gt;&gt;;</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code></pre></div>
<h2 id="mutable-matrix-range">Mutable Matrix Range</h2>
<p>Some matrices and matrix-like objects are <em>mutable</em>, meaning
that their stored values may be modified. Examples of mutable matrix
ranges include instantiations of <code>grb::matrix</code> and certain
matrix views that allow adding new values and modifying old values, such
as <code>grb::transpose</code>. We say that a type <code>M</code> is a
mutable matrix range for the scalar value <code>T</code> if the
following requirements are met.</p>
<h3 id="requirements-6">Requirements</h3>
<ol type="1">
<li><code>M</code> is a matrix range.</li>
<li>The value type of <code>M</code> fulfills the requirements of
<code>MutableMatrixEntry&lt;T, I&gt;</code>.</li>
<li><code>M</code> has a method <code>insert()</code> that takes a
matrix entry tuple and attempts to insert the element into the matrix,
returning an iterator to the new element on success and returning an
iterator to the end on failure.</li>
</ol>
<h4 id="concept-6">Concept</h4>
<div class="sourceCode" id="cb119"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> M<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> MutableMatrixRange <span class="op">=</span> MatrixRange<span class="op">&lt;</span>M<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>                             MutableMatrixEntry<span class="op">&lt;</span><span class="bu">std::</span>ranges<span class="bu">::</span>range_value_t<span class="op">&lt;</span>M<span class="op">&gt;</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>                                                grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>M<span class="op">&gt;,</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>                                                grb<span class="op">::</span><span class="dt">matrix_index_t</span><span class="op">&lt;</span>M<span class="op">&gt;,</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>                                                T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(</span>M matrix<span class="op">,</span> T value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>grb<span class="op">::</span>insert<span class="op">(</span>matrix<span class="op">,</span> <span class="op">{{</span>grb<span class="op">::</span><span class="dt">matrix_index_t</span><span class="op">&lt;</span>M<span class="op">&gt;{},</span> grb<span class="op">::</span><span class="dt">matrix_index_t</span><span class="op">&lt;</span>M<span class="op">&gt;{}},</span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>                          value<span class="op">})</span> <span class="op">-&gt;</span> <span class="bu">std::</span>ranges<span class="bu">::</span>iterator_t<span class="op">&lt;</span>M<span class="op">&gt;;</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code></pre></div>
<h2 id="mask-matrix-range">Mask Matrix Range</h2>
<p>Some operations require masks, which can be used to avoid computing
and storing certain parts of the output. We say that a type
<code>M</code> is a mask matrix range if the following requirements are
met.</p>
<h3 id="requirements-7">Requirements</h3>
<ol type="1">
<li><code>M</code> is a matrix range.</li>
<li>The scalar value type of <code>M</code> is convertible to
<code>bool</code>.</li>
</ol>
<h4 id="concept-7">Concept</h4>
<div class="sourceCode" id="cb120"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> M<span class="op">&gt;</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> MaskMatrixRange <span class="op">=</span> MatrixRange<span class="op">&lt;</span>M<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>                          <span class="bu">std::</span>is_convertible_v<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>M<span class="op">&gt;,</span> <span class="dt">bool</span><span class="op">&gt;;</span></span></code></pre></div>
<h2 id="vector-entry">Vector Entry</h2>
<p>Vector entries represent entries in a GraphBLAS vector, which include
both an <code>std::integral</code> index storing the index of the stored
scalar value, as well as the scalar value itself. We say that a type
<code>Entry</code> is a valid matrix entry for the scalar type
<code>T</code> and index type <code>I</code> if the following
requirements are met.</p>
<h3 id="requirements-8">Requirements</h3>
<ol type="1">
<li><code>Entry</code> is a tuple-like type with a size of 2.</li>
<li>The first element stored in the tuple-like type <code>Entry</code>
fulfills <code>std::integral</code>.</li>
<li>The second element stored in the tuple-like type <code>Entry</code>
holds the vector’s scalar value, and is convertible to
<code>T</code>.</li>
</ol>
<h4 id="concept-8">Concept</h4>
<div class="sourceCode" id="cb121"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Entry<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> I<span class="op">&gt;</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> VectorEntry <span class="op">=</span> TupleLike<span class="op">&lt;</span>Entry<span class="op">,</span> grb<span class="op">::</span>any<span class="op">,</span> grb<span class="op">::</span>any<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">requires</span><span class="op">(</span>Entry entry<span class="op">)</span> <span class="op">{</span> <span class="op">{</span>grb<span class="op">::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>entry<span class="op">)}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>integral<span class="op">;</span> <span class="op">}</span> <span class="op">&amp;&amp;</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">requires</span><span class="op">(</span>Entry entry<span class="op">)</span> <span class="op">{</span> <span class="op">{</span>grb<span class="op">::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>entry<span class="op">)}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>convertible_to<span class="op">&lt;</span>T<span class="op">&gt;;</span> <span class="op">};</span></span></code></pre></div>
<h2 id="mutable-vector-entry">Mutable Vector Entry</h2>
<p>A mutable vector entry is an entry in a vector that fulfills all the
requirements of vector entry, but whose stored scalar value can be
mutated by assigning to some value of type <code>U</code>. We say that a
vector entry <code>Entry</code> is a mutable vector entry for scalar
type <code>T</code>, index type <code>I</code>, and output type
<code>U</code>, if it fulfills all the requirements of vector entry as
well as the following requirements.</p>
<h3 id="requirements-9">Requirements</h3>
<ol type="1">
<li>The second element of the tuple <code>Entry</code>, representing the
scalar value, is assignable to elements of type <code>U</code>.</li>
</ol>
<h4 id="concept-9">Concept</h4>
<div class="sourceCode" id="cb122"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Entry<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> I<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> MutableVectorEntry <span class="op">=</span> VectorEntry<span class="op">&lt;</span>Entry<span class="op">,</span> T<span class="op">,</span> I<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>                             <span class="bu">std::</span>is_assignable_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>Entry<span class="op">&gt;())),</span> U<span class="op">&gt;;</span></span></code></pre></div>
<h2 id="vector-range">Vector Range</h2>
<p>A vector in GraphBLAS consists of a range of values distributed over
a one-dimensional domain. In addition to <a
href="#grb::vector"><code>grb::vector</code></a>, which directly stores
a collection of values, there are other types, such as views, that
fulfill the same interface. We say that a type <code>V</code> is a
vector range if the following requirements are met.</p>
<p><em>TODO: make requirements list find CPO, not method.</em></p>
<h3 id="requirements-10">Requirements</h3>
<ol type="1">
<li><code>V</code> has a scalar type of the stored values, accessible
with <code>grb::vector_scalar_t&lt;V&gt;</code></li>
<li><code>V</code> has an index type used to reference the indices of
the stored values, accessible with
<code>grb::vector_index_t&lt;V&gt;</code>.</li>
<li><code>V</code> is a range with a value type that represents a vector
tuple, containing both the index and scalar value for each stored
value.</li>
<li><code>V</code> has a shape, which is an integer-like object, holding
the dimension of the vector, accessible by invoking the method
<code>shape()</code> on an object of type <code>V</code>.</li>
<li><code>V</code> has a method <code>find()</code> that takes an index
and returns an iterator.</li>
</ol>
<h4 id="concept-10">Concept</h4>
<p><em>TODO: this is a bit sketchy, and needs to have some of the
components fleshed out.</em></p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> M<span class="op">&gt;</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> VectorRange <span class="op">=</span> <span class="bu">std::</span>ranges<span class="bu">::</span>sized_range<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(</span>V vector<span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>V<span class="op">&gt;;</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> grb<span class="op">::</span><span class="dt">vector_index_t</span><span class="op">&lt;</span>V<span class="op">&gt;;</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="bu">std::</span>declval<span class="op">&lt;</span><span class="bu">std::</span>ranges<span class="bu">::</span>range_value_t<span class="op">&lt;</span><span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span>V<span class="op">&gt;&gt;&gt;()}</span></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">-&gt;</span> VectorEntry<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>V<span class="op">&gt;,</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>                     grb<span class="op">::</span><span class="dt">vector_index_t</span><span class="op">&lt;</span>V<span class="op">&gt;&gt;;</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>grb<span class="op">::</span>shape<span class="op">(</span>vector<span class="op">)}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_index_t</span><span class="op">&lt;</span>V<span class="op">&gt;&gt;;</span></span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>grb<span class="op">::</span>find<span class="op">(</span>vector<span class="op">,</span> grb<span class="op">::</span><span class="dt">vector_index_t</span><span class="op">&lt;</span>V<span class="op">&gt;)}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>convertible_to<span class="op">&lt;</span><span class="bu">std::</span>ranges<span class="bu">::</span>iterator_t<span class="op">&lt;</span>V<span class="op">&gt;&gt;;</span></span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code></pre></div>
<h2 id="mutable-vector-range">Mutable Vector Range</h2>
<p>Some vectors and vector-like objects are <em>mutable</em>, meaning
that their stored values may be modified. Examples of mutable vector
ranges include instantiations of <code>grb::vector</code> and certain
vector views that allow adding new values and modifying old values, such
as <code>grb::transpose</code>. We say that a type <code>V</code> is a
mutable vector range for the scalar value <code>T</code> if the
following requirements are met.</p>
<h3 id="requirements-11">Requirements</h3>
<ol type="1">
<li><code>V</code> is a vector range.</li>
<li>The value type of <code>M</code> fulfills the requirements of
<code>MutableVectorEntry&lt;T, I&gt;</code>.</li>
<li><code>M</code> has a method <code>insert()</code> that takes a
vector entry tuple and attempts to insert the element into the vector
returning an iterator to the new element on success and returning an
iterator to the end on failure.</li>
</ol>
<h4 id="concept-11">Concept</h4>
<div class="sourceCode" id="cb124"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> V<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> MutableVectorRange <span class="op">=</span> VectorRange<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>                             MutableVectorEntry<span class="op">&lt;</span><span class="bu">std::</span>ranges<span class="bu">::</span>range_value_t<span class="op">&lt;</span>V<span class="op">&gt;,</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>                                                grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>V<span class="op">&gt;,</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>                                                grb<span class="op">::</span><span class="dt">vector_index_t</span><span class="op">&lt;</span>V<span class="op">&gt;,</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>                                                T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">requires</span><span class="op">(</span>V vector<span class="op">,</span> T value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>grb<span class="op">::</span>insert<span class="op">(</span>vector<span class="op">,</span> <span class="op">{</span>grb<span class="op">::</span><span class="dt">vector_index_t</span><span class="op">&lt;</span>V<span class="op">&gt;{},</span> value<span class="op">})}</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>      <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span><span class="bu">std::</span>ranges<span class="bu">::</span>iterator_t<span class="op">&lt;</span>V<span class="op">&gt;&gt;;</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code></pre></div>
<h2 id="mask-vector-range">Mask Vector Range</h2>
<p>Some operations require masks, which can be used to avoid computing
and storing certain parts of the output. We say that a type
<code>M</code> is a mask vector range if the following requirements are
met.</p>
<h3 id="requirements-12">Requirements</h3>
<ol type="1">
<li><code>M</code> is a vector range.</li>
<li>The scalar value type of <code>M</code> is convertible to
<code>bool</code>.</li>
</ol>
<h4 id="concept-12">Concept</h4>
<div class="sourceCode" id="cb125"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> M<span class="op">&gt;</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> MaskVectorRange <span class="op">=</span> VectorRange<span class="op">&lt;</span>M<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>                          <span class="bu">std::</span>is_convertible_v<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>M<span class="op">&gt;,</span> <span class="dt">bool</span><span class="op">&gt;;</span></span></code></pre></div>
<h1 id="type-traits">Type Traits</h1>
<h2 id="grbmonoid_traits"><code>grb::monoid_traits</code></h2>
<div class="sourceCode" id="cb126"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Fn<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> monoid_traits<span class="op">;</span></span></code></pre></div>
<p>The <code>monoid_traits</code> template struct provides information
about the monoid that is formed by the commutative binary operator
<code>Fn</code> on the type <code>T</code>. Namely, it provides a way to
retrieve the monoid’s identity.</p>
<p>Users can specialize <code>monoid_traits</code> for custom operators,
which will make their identity elements available to GraphBLAS
algorithms, possibly enabling optimizations. The default specialization
of <code>monoid_traits</code> detects and provides the identity of the
monoid if it has an <code>identity</code> method.</p>
<h2 id="template-parameters-10">Template Parameters</h2>
<p><code>Fn</code> - type of commutative binary operator</p>
<p><code>T</code> - type on which <code>Fn</code> forms a commutative
monoid</p>
<h3 id="member-types-3">Member Types</h3>
<table>
<thead>
<tr class="header">
<th>Member Type</th>
<th>Definition</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>type</code></td>
<td><code>T</code></td>
<td>type of the monoid</td>
</tr>
</tbody>
</table>
<p>The default specialization has the following member functions:</p>
<h3 id="member-functions">Member Functions</h3>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>identity</code></td>
<td>the identity value of the monoid</td>
<td></td>
</tr>
</tbody>
</table>
<h3
id="grbmonoid_traitsfn-tidentity"><code>grb::monoid_traits&lt;Fn, T&gt;::identity</code></h3>
<div class="sourceCode" id="cb127"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="kw">constexpr</span> T identity<span class="op">()</span> <span class="kw">noexcept</span><span class="op">;</span></span></code></pre></div>
<p>Returns the identity of the monoid.</p>
<h4 id="parameters-43">Parameters</h4>
<p>None</p>
<h4 id="complexity-33">Complexity</h4>
<p>Constant</p>
<h4 id="exceptions-15">Exceptions</h4>
<p>May not throw exceptions</p>
<h4 id="possible-implementation-1">Possible Implementation</h4>
<div class="sourceCode" id="cb128"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Fn<span class="op">,</span> <span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="kw">constexpr</span> T grb<span class="op">::</span>monoid_traits<span class="op">&lt;</span>Fn<span class="op">,</span> T<span class="op">&gt;::</span>identity<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="kw">constexpr</span><span class="op">(</span><span class="kw">requires</span> <span class="op">{</span> <span class="op">{</span>Fn<span class="op">::</span>identity<span class="op">()</span> <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">})</span> <span class="op">{</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Fn<span class="op">::</span>identity<span class="op">();</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span><span class="op">(</span><span class="kw">requires</span> <span class="op">{</span> <span class="op">{</span>Fn<span class="op">::</span> <span class="kw">template</span> identity<span class="op">&lt;</span>T<span class="op">&gt;()}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">})</span> <span class="op">{</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Fn<span class="op">::</span> <span class="kw">template</span> identity<span class="op">&lt;</span>T<span class="op">&gt;();</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="specializations-6">Specializations</h3>
<div class="sourceCode" id="cb129"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>arithmetic<span class="op"> </span>T<span class="op">&gt;</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> grb<span class="op">::</span>monoid_traits<span class="op">&lt;</span><span class="bu">std::</span>plus<span class="op">&lt;</span>T<span class="op">&gt;,</span> T<span class="op">&gt;;</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>arithmetic<span class="op"> </span>T<span class="op">&gt;</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> grb<span class="op">::</span>monoid_traits<span class="op">&lt;</span><span class="bu">std::</span>plus<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;,</span> T<span class="op">&gt;;</span></span></code></pre></div>
<div class="sourceCode" id="cb130"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>arithmetic<span class="op"> </span>T<span class="op">&gt;</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> grb<span class="op">::</span>monoid_traits<span class="op">&lt;</span><span class="bu">std::</span>multiplies<span class="op">&lt;</span>T<span class="op">&gt;,</span> T<span class="op">&gt;;</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>arithmetic<span class="op"> </span>T<span class="op">&gt;</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> grb<span class="op">::</span>monoid_traits<span class="op">&lt;</span><span class="bu">std::</span>multiplies<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;,</span> T<span class="op">&gt;;</span></span></code></pre></div>
<h3 id="grbmatrix_value_t"><code>grb::matrix_value_t</code></h3>
<div class="sourceCode" id="cb131"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Matrix<span class="op">&gt;</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">matrix_value_t</span> <span class="op">=</span> <span class="bu">std::</span>ranges<span class="bu">::</span>range_value_t<span class="op">&lt;</span>Matrix<span class="op">&gt;;</span></span></code></pre></div>
<p>Obtain the value type of the matrix-like type <code>Matrix</code>.
Equal to <code>std::ranges::range_value_t&lt;Matrix&gt;</code>.</p>
<h3 id="grbvector_value_t"><code>grb::vector_value_t</code></h3>
<div class="sourceCode" id="cb132"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Vector<span class="op">&gt;</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">vector_value_t</span> <span class="op">=</span> <span class="bu">std::</span>ranges<span class="bu">::</span>range_value_t<span class="op">&lt;</span>Vector<span class="op">&gt;;</span></span></code></pre></div>
<p>Obtain the value type of the vector-like type <code>Vector</code>.
Equal to <code>std::ranges::range_value_t&lt;Vector&gt;</code>.</p>
<h3 id="grbmatrix_scalar_t"><code>grb::matrix_scalar_t</code></h3>
<div class="sourceCode" id="cb133"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Matrix<span class="op">&gt;</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">matrix_scalar_t</span> <span class="op">=</span> <span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span><span class="kw">typename</span> <span class="bu">std::</span>tuple_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dt">matrix_value_t</span><span class="op">&lt;</span>Matrix<span class="op">&gt;&gt;::</span>type<span class="op">&gt;;</span></span></code></pre></div>
<p>Obtain the type of scalar values stored in the matrix-like type
<code>Matrix</code>. Equal to the second element stored in the matrix’s
tuple-like value type.</p>
<h3 id="grbvector_scalar_t"><code>grb::vector_scalar_t</code></h3>
<div class="sourceCode" id="cb134"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Vector<span class="op">&gt;</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">vector_scalar_t</span> <span class="op">=</span> <span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span><span class="kw">typename</span> <span class="bu">std::</span>tuple_element<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dt">vector_value_t</span><span class="op">&lt;</span>Vector<span class="op">&gt;&gt;::</span>type<span class="op">&gt;;</span></span></code></pre></div>
<p>Obtain the type of scalar values stored in the vector-like type
<code>Vector</code>. Equal to the second element stored in the vector’s
tuple-like value type.</p>
<h3 id="grbmatrix_key_t"><code>grb::matrix_key_t</code></h3>
<div class="sourceCode" id="cb135"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Matrix<span class="op">&gt;</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">matrix_key_t</span> <span class="op">=</span> <span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span><span class="kw">typename</span> <span class="bu">std::</span>tuple_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">,</span> <span class="dt">matrix_value_t</span><span class="op">&lt;</span>Matrix<span class="op">&gt;&gt;::</span>type<span class="op">&gt;;</span></span></code></pre></div>
<p>Obtain the key type of the matrix. This is a tuple-like type used to
store each scalar value’s row and column indices.</p>
<h3 id="grbmatrix_index_t"><code>grb::matrix_index_t</code></h3>
<div class="sourceCode" id="cb136"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Matrix<span class="op">&gt;</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">matrix_index_t</span> <span class="op">=</span> <span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span><span class="kw">typename</span> <span class="bu">std::</span>tuple_element<span class="op">&lt;</span><span class="dv">0</span><span class="op">,</span> <span class="dt">matrix_key_t</span><span class="op">&lt;</span>Matrix<span class="op">&gt;&gt;::</span>type<span class="op">&gt;;</span></span></code></pre></div>
<p>Obtain the integer-like type used to store matrix indices.</p>
<h1 id="algorithms">Algorithms</h1>
<h2 id="execution-policy">Execution Policy</h2>
<p>Execution policies are objects that indicate the kind of parallelism
allowed when executing an algorithm. For versions of GraphBLAS
algorithms that support execution policies, users may pass in the
execution policies defined in the C++ standard library.</p>
<ul>
<li><code>std::execution::sequenced_policy</code></li>
<li><code>std::execution::parallel_policy</code></li>
<li><code>std::execution::parallel_unsequenced_policy</code></li>
<li><code>std::execution::unsequenced_policy</code></li>
</ul>
<p>GraphBLAS implementations may also provide implementation-defined
execution policies. Implementations must define the execution behavior
for any execution policies they define.</p>
<h2 id="exceptions-and-error-handling">Exceptions and Error
Handling</h2>
<p>Exceptions may be thrown to indicate error conditions. A number of
exceptions are defined which will be thrown in different error
conditions.</p>
<h3 id="graphblas-defined-exceptions">GraphBLAS-Defined Exceptions</h3>
<ul>
<li><p><code>grb::out_of_range</code> is thrown if an index is provided
which lies outside the dimensions of the matrix, or if a value is not
present at the index.</p></li>
<li><p><code>grb::matrix_io::file_error</code> is thrown if a file
cannot be read.</p></li>
<li><p><code>grb::invalid_argument</code> is thrown if objects’
dimensions are incompatible.</p></li>
</ul>
<h3 id="other-exceptions">Other Exceptions</h3>
<ul>
<li>Some functions and methods may allocate temporary memory. These may
throw</li>
</ul>
<p><code>std::bad_alloc</code>. - Some functions and methods may
allocate memory using a user-provided allocator, which may throw.</p>
<ul>
<li>Some functions and methods accept user-defined binary or unary
operators. These may throw.</li>
</ul>
<h2 id="multiply">Multiply</h2>
<p>The function <code>grb::multiply</code> in GraphBLAS is used to
multiply a matrix times a matrix, a matrix times a vector, or a vector
times a matrix, depending on the types of the input arguments.</p>
<h4 id="matrix-times-matrix">Matrix Times Matrix</h4>
<div class="sourceCode" id="cb137"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange A<span class="op">,</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a><span class="dt">multiply_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Reduce<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>multiply<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span>                                                                         <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a>         B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a>         Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a>         Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a>         M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span></span>
<span id="cb137-15"><a href="#cb137-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-16"><a href="#cb137-16" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange A<span class="op">,</span></span>
<span id="cb137-17"><a href="#cb137-17" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb137-18"><a href="#cb137-18" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine <span class="op">=</span> grb<span class="op">::</span>multiplies<span class="op">&lt;&gt;,</span></span>
<span id="cb137-19"><a href="#cb137-19" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb137-20"><a href="#cb137-20" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb137-21"><a href="#cb137-21" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce <span class="op">=</span> grb<span class="op">::</span>plus<span class="op">&lt;&gt;,</span></span>
<span id="cb137-22"><a href="#cb137-22" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb137-23"><a href="#cb137-23" aria-hidden="true" tabindex="-1"></a>          MutableMatrixRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C<span class="op">,</span></span>
<span id="cb137-24"><a href="#cb137-24" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb137-25"><a href="#cb137-25" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb137-26"><a href="#cb137-26" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb137-27"><a href="#cb137-27" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> multiply<span class="op">(</span>C<span class="op">&amp;&amp;</span> c<span class="op">,</span>                                                                    <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb137-28"><a href="#cb137-28" aria-hidden="true" tabindex="-1"></a>              A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb137-29"><a href="#cb137-29" aria-hidden="true" tabindex="-1"></a>              B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb137-30"><a href="#cb137-30" aria-hidden="true" tabindex="-1"></a>              Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb137-31"><a href="#cb137-31" aria-hidden="true" tabindex="-1"></a>              Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb137-32"><a href="#cb137-32" aria-hidden="true" tabindex="-1"></a>              M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb137-33"><a href="#cb137-33" aria-hidden="true" tabindex="-1"></a>              Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb137-34"><a href="#cb137-34" aria-hidden="true" tabindex="-1"></a>              <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb137-35"><a href="#cb137-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-36"><a href="#cb137-36" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb137-37"><a href="#cb137-37" aria-hidden="true" tabindex="-1"></a>          MatrixRange A<span class="op">,</span></span>
<span id="cb137-38"><a href="#cb137-38" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb137-39"><a href="#cb137-39" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb137-40"><a href="#cb137-40" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb137-41"><a href="#cb137-41" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb137-42"><a href="#cb137-42" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb137-43"><a href="#cb137-43" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;</span></span>
<span id="cb137-44"><a href="#cb137-44" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb137-45"><a href="#cb137-45" aria-hidden="true" tabindex="-1"></a><span class="dt">multiply_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Reduce<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb137-46"><a href="#cb137-46" aria-hidden="true" tabindex="-1"></a>multiply<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span>                                                      <span class="op">(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb137-47"><a href="#cb137-47" aria-hidden="true" tabindex="-1"></a>         A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb137-48"><a href="#cb137-48" aria-hidden="true" tabindex="-1"></a>         B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb137-49"><a href="#cb137-49" aria-hidden="true" tabindex="-1"></a>         Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb137-50"><a href="#cb137-50" aria-hidden="true" tabindex="-1"></a>         Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb137-51"><a href="#cb137-51" aria-hidden="true" tabindex="-1"></a>         M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span></span>
<span id="cb137-52"><a href="#cb137-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-53"><a href="#cb137-53" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb137-54"><a href="#cb137-54" aria-hidden="true" tabindex="-1"></a>          MatrixRange A<span class="op">,</span></span>
<span id="cb137-55"><a href="#cb137-55" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb137-56"><a href="#cb137-56" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb137-57"><a href="#cb137-57" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb137-58"><a href="#cb137-58" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb137-59"><a href="#cb137-59" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb137-60"><a href="#cb137-60" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb137-61"><a href="#cb137-61" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb137-62"><a href="#cb137-62" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb137-63"><a href="#cb137-63" aria-hidden="true" tabindex="-1"></a>          MutableMatrixRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb137-64"><a href="#cb137-64" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb137-65"><a href="#cb137-65" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> multiply<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span>                                                 <span class="op">(</span><span class="dv">4</span><span class="op">)</span></span>
<span id="cb137-66"><a href="#cb137-66" aria-hidden="true" tabindex="-1"></a>              C<span class="op">&amp;&amp;</span> c<span class="op">,</span></span>
<span id="cb137-67"><a href="#cb137-67" aria-hidden="true" tabindex="-1"></a>              A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb137-68"><a href="#cb137-68" aria-hidden="true" tabindex="-1"></a>              B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb137-69"><a href="#cb137-69" aria-hidden="true" tabindex="-1"></a>              Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb137-70"><a href="#cb137-70" aria-hidden="true" tabindex="-1"></a>              Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb137-71"><a href="#cb137-71" aria-hidden="true" tabindex="-1"></a>              M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb137-72"><a href="#cb137-72" aria-hidden="true" tabindex="-1"></a>              Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb137-73"><a href="#cb137-73" aria-hidden="true" tabindex="-1"></a>              <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span></span></code></pre></div>
<h4 id="matrix-times-vector">Matrix Times Vector</h4>
<div class="sourceCode" id="cb138"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange A<span class="op">,</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;</span></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>mutiply_result<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Reduce<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a>multiply<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span>                                                                         <span class="op">(</span><span class="dv">5</span><span class="op">)</span></span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a>         B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a>         Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a>         Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true" tabindex="-1"></a>         M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span></span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-16"><a href="#cb138-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-17"><a href="#cb138-17" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange A<span class="op">,</span></span>
<span id="cb138-18"><a href="#cb138-18" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb138-19"><a href="#cb138-19" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine <span class="op">=</span> grb<span class="op">::</span>multiplies<span class="op">&lt;&gt;,</span></span>
<span id="cb138-20"><a href="#cb138-20" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb138-21"><a href="#cb138-21" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb138-22"><a href="#cb138-22" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce <span class="op">=</span> grb<span class="op">::</span>plus<span class="op">&lt;&gt;,</span></span>
<span id="cb138-23"><a href="#cb138-23" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb138-24"><a href="#cb138-24" aria-hidden="true" tabindex="-1"></a>          MutableVectorRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C<span class="op">,</span></span>
<span id="cb138-25"><a href="#cb138-25" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb138-26"><a href="#cb138-26" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">&lt;&gt;</span></span>
<span id="cb138-27"><a href="#cb138-27" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb138-28"><a href="#cb138-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> multiply<span class="op">(</span>C<span class="op">&amp;&amp;</span> c<span class="op">,</span>                                                                    <span class="op">(</span><span class="dv">6</span><span class="op">)</span></span>
<span id="cb138-29"><a href="#cb138-29" aria-hidden="true" tabindex="-1"></a>              A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb138-30"><a href="#cb138-30" aria-hidden="true" tabindex="-1"></a>              B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb138-31"><a href="#cb138-31" aria-hidden="true" tabindex="-1"></a>              Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb138-32"><a href="#cb138-32" aria-hidden="true" tabindex="-1"></a>              Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb138-33"><a href="#cb138-33" aria-hidden="true" tabindex="-1"></a>              M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb138-34"><a href="#cb138-34" aria-hidden="true" tabindex="-1"></a>              Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb138-35"><a href="#cb138-35" aria-hidden="true" tabindex="-1"></a>              <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb138-36"><a href="#cb138-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-37"><a href="#cb138-37" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb138-38"><a href="#cb138-38" aria-hidden="true" tabindex="-1"></a>          MatrixRange A<span class="op">,</span></span>
<span id="cb138-39"><a href="#cb138-39" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb138-40"><a href="#cb138-40" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb138-41"><a href="#cb138-41" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb138-42"><a href="#cb138-42" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb138-43"><a href="#cb138-43" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb138-44"><a href="#cb138-44" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;</span></span>
<span id="cb138-45"><a href="#cb138-45" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb138-46"><a href="#cb138-46" aria-hidden="true" tabindex="-1"></a>mutiply_result<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Reduce<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb138-47"><a href="#cb138-47" aria-hidden="true" tabindex="-1"></a>multiply<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span>                                                                         <span class="op">(</span><span class="dv">7</span><span class="op">)</span></span>
<span id="cb138-48"><a href="#cb138-48" aria-hidden="true" tabindex="-1"></a>         B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb138-49"><a href="#cb138-49" aria-hidden="true" tabindex="-1"></a>         Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb138-50"><a href="#cb138-50" aria-hidden="true" tabindex="-1"></a>         Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb138-51"><a href="#cb138-51" aria-hidden="true" tabindex="-1"></a>         M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span></span>
<span id="cb138-52"><a href="#cb138-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-53"><a href="#cb138-53" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb138-54"><a href="#cb138-54" aria-hidden="true" tabindex="-1"></a>          MatrixRange A<span class="op">,</span></span>
<span id="cb138-55"><a href="#cb138-55" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb138-56"><a href="#cb138-56" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb138-57"><a href="#cb138-57" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb138-58"><a href="#cb138-58" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb138-59"><a href="#cb138-59" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb138-60"><a href="#cb138-60" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb138-61"><a href="#cb138-61" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb138-62"><a href="#cb138-62" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb138-63"><a href="#cb138-63" aria-hidden="true" tabindex="-1"></a>          MutableVectorRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb138-64"><a href="#cb138-64" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb138-65"><a href="#cb138-65" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> multiply<span class="op">(</span>C<span class="op">&amp;&amp;</span> c<span class="op">,</span>                                                                    <span class="op">(</span><span class="dv">8</span><span class="op">)</span></span>
<span id="cb138-66"><a href="#cb138-66" aria-hidden="true" tabindex="-1"></a>              A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb138-67"><a href="#cb138-67" aria-hidden="true" tabindex="-1"></a>              B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb138-68"><a href="#cb138-68" aria-hidden="true" tabindex="-1"></a>              Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb138-69"><a href="#cb138-69" aria-hidden="true" tabindex="-1"></a>              Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb138-70"><a href="#cb138-70" aria-hidden="true" tabindex="-1"></a>              M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb138-71"><a href="#cb138-71" aria-hidden="true" tabindex="-1"></a>              Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb138-72"><a href="#cb138-72" aria-hidden="true" tabindex="-1"></a>              <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span></span></code></pre></div>
<h4 id="vector-times-vector">Vector Times Vector</h4>
<div class="sourceCode" id="cb139"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange A<span class="op">,</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>mutiply_result<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Reduce<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>multiply<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span>                                                                         <span class="op">(</span><span class="dv">9</span><span class="op">)</span></span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a>         B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a>         Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a>         Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{});</span></span>
<span id="cb139-13"><a href="#cb139-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-14"><a href="#cb139-14" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange A<span class="op">,</span></span>
<span id="cb139-15"><a href="#cb139-15" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb139-16"><a href="#cb139-16" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb139-17"><a href="#cb139-17" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb139-18"><a href="#cb139-18" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb139-19"><a href="#cb139-19" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb139-20"><a href="#cb139-20" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb139-21"><a href="#cb139-21" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb139-22"><a href="#cb139-22" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>assignable_from<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb139-23"><a href="#cb139-23" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb139-24"><a href="#cb139-24" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> multiply<span class="op">(</span>C<span class="op">&amp;&amp;</span> c<span class="op">,</span>                                                                   <span class="op">(</span><span class="dv">10</span><span class="op">)</span></span>
<span id="cb139-25"><a href="#cb139-25" aria-hidden="true" tabindex="-1"></a>              A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb139-26"><a href="#cb139-26" aria-hidden="true" tabindex="-1"></a>              B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb139-27"><a href="#cb139-27" aria-hidden="true" tabindex="-1"></a>              Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb139-28"><a href="#cb139-28" aria-hidden="true" tabindex="-1"></a>              Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb139-29"><a href="#cb139-29" aria-hidden="true" tabindex="-1"></a>              Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb139-30"><a href="#cb139-30" aria-hidden="true" tabindex="-1"></a>              <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb139-31"><a href="#cb139-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-32"><a href="#cb139-32" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb139-33"><a href="#cb139-33" aria-hidden="true" tabindex="-1"></a>          VectorRange A<span class="op">,</span></span>
<span id="cb139-34"><a href="#cb139-34" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb139-35"><a href="#cb139-35" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb139-36"><a href="#cb139-36" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb139-37"><a href="#cb139-37" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb139-38"><a href="#cb139-38" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb139-39"><a href="#cb139-39" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb139-40"><a href="#cb139-40" aria-hidden="true" tabindex="-1"></a>mutiply_result<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Reduce<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb139-41"><a href="#cb139-41" aria-hidden="true" tabindex="-1"></a>multiply<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span>                                                     <span class="op">(</span><span class="dv">11</span><span class="op">)</span></span>
<span id="cb139-42"><a href="#cb139-42" aria-hidden="true" tabindex="-1"></a>         A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb139-43"><a href="#cb139-43" aria-hidden="true" tabindex="-1"></a>         B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb139-44"><a href="#cb139-44" aria-hidden="true" tabindex="-1"></a>         Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb139-45"><a href="#cb139-45" aria-hidden="true" tabindex="-1"></a>         Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{});</span></span>
<span id="cb139-46"><a href="#cb139-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-47"><a href="#cb139-47" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb139-48"><a href="#cb139-48" aria-hidden="true" tabindex="-1"></a>          VectorRange A<span class="op">,</span></span>
<span id="cb139-49"><a href="#cb139-49" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb139-50"><a href="#cb139-50" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb139-51"><a href="#cb139-51" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb139-52"><a href="#cb139-52" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb139-53"><a href="#cb139-53" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb139-54"><a href="#cb139-54" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb139-55"><a href="#cb139-55" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb139-56"><a href="#cb139-56" aria-hidden="true" tabindex="-1"></a>          <span class="bu">std::</span>assignable_from<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb139-57"><a href="#cb139-57" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb139-58"><a href="#cb139-58" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> multiply<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span>                                                <span class="op">(</span><span class="dv">12</span><span class="op">)</span></span>
<span id="cb139-59"><a href="#cb139-59" aria-hidden="true" tabindex="-1"></a>              C<span class="op">&amp;&amp;</span> c<span class="op">,</span></span>
<span id="cb139-60"><a href="#cb139-60" aria-hidden="true" tabindex="-1"></a>              A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb139-61"><a href="#cb139-61" aria-hidden="true" tabindex="-1"></a>              B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb139-62"><a href="#cb139-62" aria-hidden="true" tabindex="-1"></a>              Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb139-63"><a href="#cb139-63" aria-hidden="true" tabindex="-1"></a>              Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb139-64"><a href="#cb139-64" aria-hidden="true" tabindex="-1"></a>              Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb139-65"><a href="#cb139-65" aria-hidden="true" tabindex="-1"></a>              <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span></span></code></pre></div>
<h4 id="vector-times-matrix">Vector Times Matrix</h4>
<div class="sourceCode" id="cb140"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange A<span class="op">,</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a>mutiply_result<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Reduce<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a>multiply<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span>                                                                        <span class="op">(</span><span class="dv">13</span><span class="op">)</span></span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>         B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a>         Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a>         Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a>         M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange A<span class="op">,</span></span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb140-18"><a href="#cb140-18" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine <span class="op">=</span> grb<span class="op">::</span>multiplies<span class="op">&lt;&gt;,</span></span>
<span id="cb140-19"><a href="#cb140-19" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb140-20"><a href="#cb140-20" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb140-21"><a href="#cb140-21" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce <span class="op">=</span> grb<span class="op">::</span>plus<span class="op">&lt;&gt;,</span></span>
<span id="cb140-22"><a href="#cb140-22" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb140-23"><a href="#cb140-23" aria-hidden="true" tabindex="-1"></a>          MutableVectorRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C<span class="op">,</span></span>
<span id="cb140-24"><a href="#cb140-24" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb140-25"><a href="#cb140-25" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb140-26"><a href="#cb140-26" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb140-27"><a href="#cb140-27" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> multiply<span class="op">(</span>C<span class="op">&amp;&amp;</span> c<span class="op">,</span>                                                                   <span class="op">(</span><span class="dv">14</span><span class="op">)</span></span>
<span id="cb140-28"><a href="#cb140-28" aria-hidden="true" tabindex="-1"></a>              A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb140-29"><a href="#cb140-29" aria-hidden="true" tabindex="-1"></a>              B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb140-30"><a href="#cb140-30" aria-hidden="true" tabindex="-1"></a>              Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb140-31"><a href="#cb140-31" aria-hidden="true" tabindex="-1"></a>              Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb140-32"><a href="#cb140-32" aria-hidden="true" tabindex="-1"></a>              M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb140-33"><a href="#cb140-33" aria-hidden="true" tabindex="-1"></a>              Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb140-34"><a href="#cb140-34" aria-hidden="true" tabindex="-1"></a>              <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb140-35"><a href="#cb140-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-36"><a href="#cb140-36" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb140-37"><a href="#cb140-37" aria-hidden="true" tabindex="-1"></a>          VectorRange A<span class="op">,</span></span>
<span id="cb140-38"><a href="#cb140-38" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb140-39"><a href="#cb140-39" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb140-40"><a href="#cb140-40" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb140-41"><a href="#cb140-41" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb140-42"><a href="#cb140-42" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb140-43"><a href="#cb140-43" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;</span></span>
<span id="cb140-44"><a href="#cb140-44" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb140-45"><a href="#cb140-45" aria-hidden="true" tabindex="-1"></a>mutiply_result<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Reduce<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb140-46"><a href="#cb140-46" aria-hidden="true" tabindex="-1"></a>multiply<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span>                                                     <span class="op">(</span><span class="dv">15</span><span class="op">)</span></span>
<span id="cb140-47"><a href="#cb140-47" aria-hidden="true" tabindex="-1"></a>         A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb140-48"><a href="#cb140-48" aria-hidden="true" tabindex="-1"></a>         B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb140-49"><a href="#cb140-49" aria-hidden="true" tabindex="-1"></a>         Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb140-50"><a href="#cb140-50" aria-hidden="true" tabindex="-1"></a>         Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb140-51"><a href="#cb140-51" aria-hidden="true" tabindex="-1"></a>         M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span></span>
<span id="cb140-52"><a href="#cb140-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-53"><a href="#cb140-53" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb140-54"><a href="#cb140-54" aria-hidden="true" tabindex="-1"></a>          VectorRange A<span class="op">,</span></span>
<span id="cb140-55"><a href="#cb140-55" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb140-56"><a href="#cb140-56" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span> grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb140-57"><a href="#cb140-57" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb140-58"><a href="#cb140-58" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;,</span></span>
<span id="cb140-59"><a href="#cb140-59" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Reduce<span class="op">,</span></span>
<span id="cb140-60"><a href="#cb140-60" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb140-61"><a href="#cb140-61" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb140-62"><a href="#cb140-62" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb140-63"><a href="#cb140-63" aria-hidden="true" tabindex="-1"></a>          MutableVectorRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb140-64"><a href="#cb140-64" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb140-65"><a href="#cb140-65" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> multiply<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span>                                                <span class="op">(</span><span class="dv">16</span><span class="op">)</span></span>
<span id="cb140-66"><a href="#cb140-66" aria-hidden="true" tabindex="-1"></a>              C<span class="op">&amp;&amp;</span> c<span class="op">,</span></span>
<span id="cb140-67"><a href="#cb140-67" aria-hidden="true" tabindex="-1"></a>              A<span class="op">&amp;&amp;</span> a<span class="op">,</span></span>
<span id="cb140-68"><a href="#cb140-68" aria-hidden="true" tabindex="-1"></a>              B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb140-69"><a href="#cb140-69" aria-hidden="true" tabindex="-1"></a>              Reduce<span class="op">&amp;&amp;</span> reduce <span class="op">=</span> Reduce<span class="op">{},</span></span>
<span id="cb140-70"><a href="#cb140-70" aria-hidden="true" tabindex="-1"></a>              Combine<span class="op">&amp;&amp;</span> combine <span class="op">=</span> Combine<span class="op">{},</span></span>
<span id="cb140-71"><a href="#cb140-71" aria-hidden="true" tabindex="-1"></a>              M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb140-72"><a href="#cb140-72" aria-hidden="true" tabindex="-1"></a>              Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb140-73"><a href="#cb140-73" aria-hidden="true" tabindex="-1"></a>              <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span></span></code></pre></div>
<p>Behavior is non-deterministic if <code>reduce</code> is not
associative or not commutative.</p>
<h3 id="parameters-44">Parameters</h3>
<p><code>policy</code> - the execution policy to use</p>
<p><code>a</code> - the left-hand side of the product being computed</p>
<p><code>b</code> - the right-hand side of the product being
computed</p>
<p><code>reduce</code> - a binary operator</p>
<p><code>combine</code> - a binary operator</p>
<p><code>mask</code> - write mask used to determine which elements of
the output will be computed</p>
<p><code>c</code> - if given, the output object to which to write the
result</p>
<p><code>acc</code> - the accumulator used to accumulate partial results
into the output object</p>
<p><code>merge</code> - whether to merge in values from <code>c</code>
outside of the write area indicated by <code>mask</code></p>
<h4 id="type-requirements-8">Type Requirements</h4>
<ul>
<li><p><code>A</code> must meet the requirements of
<code>MatrixRange</code> (1-8) or <code>VectorRange</code>
(9-16)</p></li>
<li><p><code>B</code> must meet the requirements of
<code>MatrixRange</code> (1-4,13-16) or <code>VectorRange</code>
(5-12)</p></li>
<li><p><code>Reduce</code> must meet the requirements of
<code>BinaryOperator&lt;grb::combine_result_type_t&lt;A, B, Combine&gt;, grb::combine_result_type_t&lt;A, B, Combine&gt;, grb::combine_result_type_t&lt;A, B, Combine&gt;&gt;</code></p></li>
<li><p><code>Combine</code> must meet the requirements of
<code>BinaryOperator&lt;grb::container_value_t&lt;A&gt;, grb::container_value_t&lt;B&gt;&gt;</code></p></li>
<li><p><code>M</code> must meet the requirements of
<code>MaskMatrixRange</code> (1-8) or <code>VectorMaskRange</code>
(9-16)</p></li>
</ul>
<h3 id="return-value-40">Return Value</h3>
<p>If the output matrix or vector argument, <code>c</code>, is supplied,
no value is returned.</p>
<p><strong>NOTE: `combine_result_t&lt;A, B, Combine&gt; is actually
incorrect here. Should be result of reduction.</strong></p>
<p>If <code>c</code> is not supplied as an argument, returns the result
of the multiplication.</p>
<ol type="1">
<li><ul>
<li>A GraphBLAS matrix with shape <code>a.shape()[0]</code> by
<code>b.shape()[1]</code></li>
</ul></li>
<li><ul>
<li>A GraphBLAS vector with shape <code>a.shape()[0]</code></li>
</ul></li>
<li><ul>
<li><code>combine_result_t&lt;A, B, Combine&gt;</code></li>
</ul></li>
<li><ul>
<li>A GraphBLAS vector with shape <code>b.shape()[1]</code></li>
</ul></li>
</ol>
<p>In the case that a GraphBLAS matrix or vector is returned, its scalar
type is <code>combine_result_t&lt;A, B, Combine&gt;</code>, and its
index type is equal to either <code>grb::matrix_index_t&lt;A&gt;</code>
or <code>grb::matrix_index_t&lt;B&gt;</code>, whichever one has the
larger <code>std::numeric_limits&lt;T&gt;::max()</code>. An element of
the result at index location <code>index</code> will only be computed if
a scalar value equal to <code>true</code> when converted to
<code>bool</code> exists in <code>mask</code>, that is
<code>grb::find(mask, index) != grb::end(mask) &amp;&amp; bool(grb::get&lt;1&gt;(*grb::find(mask, index)))</code>.</p>
<h5 id="matrix-times-matrix-1">Matrix Times Matrix</h5>
<p>A generalized matrix times matrix multiplication is performed, as
defined in the <a
href="https:://github.com/GraphBLAS/graphblas-api-math">GraphBLAS Math
Specification</a>. Each element of the output is produced by combing the
elements in corresponding indices of a row of <code>a</code> and column
of <code>b</code> and using <code>reduce</code> to perform a reduction
to a single value.</p>
<h5 id="matrix-times-vector-1">Matrix Times Vector</h5>
<p>A generalized matrix times vector multiplication is performed, as
defined in the <a
href="https:://github.com/GraphBLAS/graphblas-api-math">GraphBLAS Math
Specification</a>. Each element of the output vector is produced by
combining elements in each row of <code>a</code> with the corresponding
elements of the vector <code>b</code> and using <code>reduce</code> to
perform a reduction of these to a single value in the output vector.</p>
<h5 id="vector-times-vector-1">Vector Times Vector</h5>
<p>A generalized dot product is performed, as defined in the <a
href="https:://github.com/GraphBLAS/graphblas-api-math">GraphBLAS Math
Specification</a>. The corresponding elements of vectors <code>a</code>
and <code>b</code> are combined and reduced into a single value using
<code>reduce</code>.</p>
<h5 id="vector-times-matrix-1">Vector Times Matrix</h5>
<p>A generalized matrix times vector multiplication is performed, as
defined in the <a
href="https:://github.com/GraphBLAS/graphblas-api-math">GraphBLAS Math
Specification</a>. Each element of the output vector is produced by
combining elements in each column of <code>b</code> with the
corresponding elements of the vector <code>a</code> and using
<code>reduce</code> to perform a reduction of these to a single value in
the output vector.</p>
<h3 id="complexity-34">Complexity</h3>
<p>Complexity is implementation-defined.</p>
<h3 id="exceptions-16">Exceptions</h3>
<p>The exception <code>grb::invalid_argument</code> may be thrown if any
of the following conditions occur:</p>
<h5 id="matrix-times-matrix-2">Matrix Times Matrix</h5>
<ul>
<li>The dimensions of the matrices being multiplied are incompatible,
that is <code>a.shape()[1] != b.shape()[0]</code>.</li>
<li>The dimensions of the mask are smaller than the dimensions of the
output, that is
<code>mask.shape()[0] &lt; a.shape()[0] || mask.shape()[1] &lt; b.shape()[1]</code></li>
<li>The dimensions of the output matrix, if provided, are incompatible,
that is
<code>c.shape()[0] != a.shape()[0] || c.shape()[1] != b.shape()[1]</code>.</li>
</ul>
<h5 id="matrix-times-vector-2">Matrix Times Vector</h5>
<ul>
<li>The dimensions of the matrix and vector being multiplied are
incompatible, that is <code>a.shape()[1] != b.shape()</code>.</li>
<li>The dimensions of the mask are smaller than the dimensions of the
output, that is <code>mask.shape() &lt; a.shape()[0]</code></li>
<li>The dimensions of the output vector, if provided, are incompatible,
that is <code>c.shape() != a.shape()[0]</code>.</li>
</ul>
<h5 id="vector-times-vector-2">Vector Times Vector</h5>
<ul>
<li>The dimensions of the vectors being multiplied are incompatible,
that is <code>a.shape() != b.shape()</code>.</li>
<li>The dimensions of the mask are smaller than the dimensions of the
output, that is <code>mask.shape() &lt; a.shape()[0]</code></li>
<li>The dimensions of the output vector, if provided, are incompatible,
that is <code>c.shape() != a.shape()[0]</code>.</li>
</ul>
<h5 id="vector-times-matrix-2">Vector Times Matrix</h5>
<ul>
<li>The dimensions of the matrix and vector being multiplied are
incompatible, that is <code>a.shape() != b.shape()[0]</code>.</li>
<li>The dimensions of the mask are smaller than the dimensions of the
output, that is <code>mask.shape() &lt; b.shape()[1]</code></li>
<li>The dimensions of the output vector, if provided, are incompatible,
that is <code>c.shape() != b.shape()[1]</code>.</li>
</ul>
<p>If the algorithm fails to allocate memory,
<code>std::bad_alloc</code> is thrown.</p>
<h3 id="notes-1">Notes</h3>
<h3 id="example-5">Example</h3>
<h2 id="ewise_union"><code>ewise_union</code></h2>
<p>Perform an element-wise union between two GraphBLAS matrices or
vectors.</p>
<h4 id="element-wise-matrix-union">Element-Wise Matrix Union</h4>
<div class="sourceCode" id="cb141"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange A<span class="op">,</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a><span class="dt">ewise_union_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>ewise_union<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span> Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span>                <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange A<span class="op">,</span></span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a>          MutableMatrixRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ewise_union<span class="op">(</span>C<span class="op">&amp;&amp;</span> c<span class="op">,</span> A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a>                 Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb141-21"><a href="#cb141-21" aria-hidden="true" tabindex="-1"></a>                 Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb141-22"><a href="#cb141-22" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span>                                        <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb141-23"><a href="#cb141-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-24"><a href="#cb141-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-25"><a href="#cb141-25" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb141-26"><a href="#cb141-26" aria-hidden="true" tabindex="-1"></a>          MatrixRange A<span class="op">,</span></span>
<span id="cb141-27"><a href="#cb141-27" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb141-28"><a href="#cb141-28" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb141-29"><a href="#cb141-29" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb141-30"><a href="#cb141-30" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;</span></span>
<span id="cb141-31"><a href="#cb141-31" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb141-32"><a href="#cb141-32" aria-hidden="true" tabindex="-1"></a><span class="dt">ewise_union_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb141-33"><a href="#cb141-33" aria-hidden="true" tabindex="-1"></a>ewise_union<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span></span>
<span id="cb141-34"><a href="#cb141-34" aria-hidden="true" tabindex="-1"></a>            A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb141-35"><a href="#cb141-35" aria-hidden="true" tabindex="-1"></a>            Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span>                              <span class="op">(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb141-36"><a href="#cb141-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-37"><a href="#cb141-37" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb141-38"><a href="#cb141-38" aria-hidden="true" tabindex="-1"></a>          MatrixRange A<span class="op">,</span></span>
<span id="cb141-39"><a href="#cb141-39" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb141-40"><a href="#cb141-40" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb141-41"><a href="#cb141-41" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb141-42"><a href="#cb141-42" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb141-43"><a href="#cb141-43" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb141-44"><a href="#cb141-44" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb141-45"><a href="#cb141-45" aria-hidden="true" tabindex="-1"></a>          MutableMatrixRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb141-46"><a href="#cb141-46" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb141-47"><a href="#cb141-47" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ewise_union<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span></span>
<span id="cb141-48"><a href="#cb141-48" aria-hidden="true" tabindex="-1"></a>                 C<span class="op">&amp;&amp;</span> c<span class="op">,</span> A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb141-49"><a href="#cb141-49" aria-hidden="true" tabindex="-1"></a>                 Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb141-50"><a href="#cb141-50" aria-hidden="true" tabindex="-1"></a>                 Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb141-51"><a href="#cb141-51" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span>                                        <span class="op">(</span><span class="dv">4</span><span class="op">)</span></span></code></pre></div>
<h4 id="element-wise-vector-union">Element-Wise Vector Union</h4>
<div class="sourceCode" id="cb142"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange A<span class="op">,</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a><span class="dt">ewise_union_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a>ewise_union<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span> Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span>                <span class="op">(</span><span class="dv">5</span><span class="op">)</span></span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange A<span class="op">,</span></span>
<span id="cb142-11"><a href="#cb142-11" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb142-12"><a href="#cb142-12" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb142-13"><a href="#cb142-13" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb142-14"><a href="#cb142-14" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb142-15"><a href="#cb142-15" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb142-16"><a href="#cb142-16" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb142-17"><a href="#cb142-17" aria-hidden="true" tabindex="-1"></a>          MutableVectorRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb142-18"><a href="#cb142-18" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb142-19"><a href="#cb142-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ewise_union<span class="op">(</span>C<span class="op">&amp;&amp;</span> c<span class="op">,</span> A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb142-20"><a href="#cb142-20" aria-hidden="true" tabindex="-1"></a>                 Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb142-21"><a href="#cb142-21" aria-hidden="true" tabindex="-1"></a>                 Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb142-22"><a href="#cb142-22" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span>                                        <span class="op">(</span><span class="dv">6</span><span class="op">)</span></span>
<span id="cb142-23"><a href="#cb142-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-24"><a href="#cb142-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-25"><a href="#cb142-25" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb142-26"><a href="#cb142-26" aria-hidden="true" tabindex="-1"></a>          VectorRange A<span class="op">,</span></span>
<span id="cb142-27"><a href="#cb142-27" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb142-28"><a href="#cb142-28" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb142-29"><a href="#cb142-29" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb142-30"><a href="#cb142-30" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;</span></span>
<span id="cb142-31"><a href="#cb142-31" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb142-32"><a href="#cb142-32" aria-hidden="true" tabindex="-1"></a><span class="dt">ewise_union_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb142-33"><a href="#cb142-33" aria-hidden="true" tabindex="-1"></a>ewise_union<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span></span>
<span id="cb142-34"><a href="#cb142-34" aria-hidden="true" tabindex="-1"></a>            A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb142-35"><a href="#cb142-35" aria-hidden="true" tabindex="-1"></a>            Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span>                              <span class="op">(</span><span class="dv">7</span><span class="op">)</span></span>
<span id="cb142-36"><a href="#cb142-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-37"><a href="#cb142-37" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb142-38"><a href="#cb142-38" aria-hidden="true" tabindex="-1"></a>          VectorRange A<span class="op">,</span></span>
<span id="cb142-39"><a href="#cb142-39" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb142-40"><a href="#cb142-40" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb142-41"><a href="#cb142-41" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb142-42"><a href="#cb142-42" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb142-43"><a href="#cb142-43" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb142-44"><a href="#cb142-44" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb142-45"><a href="#cb142-45" aria-hidden="true" tabindex="-1"></a>          MutableVectorRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb142-46"><a href="#cb142-46" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb142-47"><a href="#cb142-47" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ewise_union<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span></span>
<span id="cb142-48"><a href="#cb142-48" aria-hidden="true" tabindex="-1"></a>                 C<span class="op">&amp;&amp;</span> c<span class="op">,</span> A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb142-49"><a href="#cb142-49" aria-hidden="true" tabindex="-1"></a>                 Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb142-50"><a href="#cb142-50" aria-hidden="true" tabindex="-1"></a>                 Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb142-51"><a href="#cb142-51" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span>                                        <span class="op">(</span><span class="dv">8</span><span class="op">)</span></span></code></pre></div>
<h3 id="parameters-45">Parameters</h3>
<p><code>policy</code> - the execution policy to use</p>
<p><code>a</code> - matrix or vector on the left-hand side of the
element-wise operation</p>
<p><code>b</code> - matrix or vector on the right-hand side of the
element-wise operation</p>
<p><code>c</code> - output matrix or vector in which to store the result
of the multiply operation</p>
<p><code>combine</code> - binary operator used to combine elements of
<code>a</code> and <code>b</code></p>
<p><code>mask</code> - determines which parts of the output matrix will
be computed</p>
<p><code>acc</code> - binary operator used to combine elements of the
result with stored elements in corresponding locations in
<code>c</code></p>
<p><code>merge</code> - flag declaring whether to merge in elements of
<code>c</code> outside the range indicated by <code>mask</code></p>
<h4 id="type-requirements-9">Type Requirements</h4>
<ul>
<li><p><code>A</code> must meet the requirements of
<code>MatrixRange</code> (1,2,3,4) or <code>VectorRange</code>
(5,6,7,8).</p></li>
<li><p><code>B</code> must meet the requirements of
<code>MatrixRange</code> (1,2,3,4) or <code>VectorRange</code>
(5,6,7,8).</p></li>
<li><p><code>C</code> must meet the requirements of
<code>MutableMatrixRange&lt;grb::combine_result_t&lt;A, B, Combine&gt;&gt;</code>
(2,4) or
<code>MutableVectorRange&lt;grb::combine_result_t&lt;A, B, Combine&gt;&gt;</code>
(6,8).</p></li>
<li><p><code>Combine</code> must meet the requirements of
<code>BinaryOperator&lt;grb::matrix_scalar_t&lt;A&gt;, grb::matrix_scalar_t&lt;B&gt;&gt;</code>
(1,2,3,4) or
<code>BinaryOperator&lt;grb::vector_scalar_t&lt;A&gt;, grb::vector_scalar_t&lt;B&gt;&gt;</code>
(5,6,7,8).</p></li>
<li><p><code>M</code> must meet the requirements of
<code>MaskMatrixRange</code> (1,2,3,4) or <code>MaskVectorRange</code>
(5,6,7,8).</p></li>
<li><p><code>Accumulate</code> must meet the requirements of
<code>BinaryOperator&lt;grb::matrix_scalar_t&lt;C&gt;, grb::combine_result_t&lt;A, B, Combine&gt;&gt;</code>
(2,4) or
<code>BinaryOperator&lt;grb::vector_scalar_t&lt;C&gt;, grb::combine_result_t&lt;A, B, Combine&gt;&gt;</code>
(6,8).</p></li>
</ul>
<h3 id="return-value-41">Return Value</h3>
<p>If the output matrix or vector parameter, <code>c</code>, is
supplied, no value is returned.</p>
<p>If the parameter <code>c</code> is not supplied, the function returns
a GraphBLAS matrix (1,3) or GraphBLAS vector (5,7) equal to the
element-wise union of <code>a</code> and <code>b</code>, with the binary
operator <code>combine</code> used to combine scalar values stored at
the same index and <code>mask</code> used to determine which parts of
the output are computed. For (1,3), the type of the return value
satisfies the requirements of <code>MatrixRange</code>, and for (5,7)
the type of the return value satisfies the requirements of
<code>VectorRange</code>. The return value has the same shape as
<code>a</code> and <code>b</code>. Index <code>idx</code> in the return
value holds a stored value if and only if an element exists at that
index in both <code>a</code> or <code>b</code> and an element equal to
<code>true</code> when cast to <code>bool</code> exists at that index in
<code>mask</code>. If a value exists at <code>idx</code> in
<code>a</code> but not in <code>b</code>, the return value will hold a
value equal to <code>a[idx]</code>. If a value exists in <code>b</code>
but not in <code>a</code>, it will hold a value equal to
<code>b[idx]</code>. If a value exists at <code>idx</code> in both
<code>a</code> and <code>b</code>, it will hold a value equal to
<code>fn(a[idx], b[idx])</code>.</p>
<h3 id="preconditions">Preconditions</h3>
<p>The parameters <code>a</code> and <code>b</code> must share the same
shape. If an output object <code>c</code> is given, it must also have
the same shape. For the parameter <code>mask</code>, each dimension of
its shape must be equal to or greater than the corresponding dimension
of <code>a</code> and <code>b</code>’s shapes. <code>fn</code> must not
modify any element of <code>a</code>, <code>b</code>, or
<code>mask</code>.</p>
<h3 id="postconditions">Postconditions</h3>
<p>In (2,4) and (6,8), an element-wise union is performed as described
in the <a
href="https://github.com/GraphBLAS/graphblas-api-math">GraphBLAS Math
Specification</a> and the result written to <code>c</code>. In (1,3) and
(5,7), none of the input arguments will be modified, and the result is
returned as a value.</p>
<h3 id="exceptions-17">Exceptions</h3>
<p>The exception <code>grb::invalid_argument</code> may be thrown if any
of the following conditions occur:</p>
<ul>
<li>The dimensions of <code>a</code> and <code>b</code> incompatible,
that is <code>a.shape() != b.shape()</code>.</li>
<li>The dimensions of <code>c</code>, if given, does not match
<code>a</code>’s shape, that is <code>c.shape() != a.shape()</code></li>
<li>The dimensions of the mask are smaller than the dimensions of the
output, that is
<code>mask.shape()[0] &lt; a.shape()[0] || mask.shape()[1] &lt; a.shape()[1]</code>
(1,2,3,4) or <code>mask.shape() &lt; a.shape()</code> in (5,6,7,8).</li>
</ul>
<h3 id="notes-2">Notes</h3>
<h3 id="example-6">Example</h3>
<div class="sourceCode" id="cb143"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;grb/grb.hpp&gt;</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">**</span> argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>matrix<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> x<span class="op">({</span><span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">});</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>matrix<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> y<span class="op">({</span><span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">});</span></span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>  x<span class="op">[{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a>  x<span class="op">[{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a>  x<span class="op">[{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a>  x<span class="op">[{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true" tabindex="-1"></a>  y<span class="op">[{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb143-13"><a href="#cb143-13" aria-hidden="true" tabindex="-1"></a>  y<span class="op">[{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb143-14"><a href="#cb143-14" aria-hidden="true" tabindex="-1"></a>  y<span class="op">[{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb143-15"><a href="#cb143-15" aria-hidden="true" tabindex="-1"></a>  y<span class="op">[{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb143-16"><a href="#cb143-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-17"><a href="#cb143-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> z <span class="op">=</span> grb<span class="op">::</span>ewise_union<span class="op">(</span>x<span class="op">,</span> y<span class="op">,</span> grb<span class="op">::</span>plus<span class="op">{});</span></span>
<span id="cb143-18"><a href="#cb143-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-19"><a href="#cb143-19" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>print<span class="op">(</span>z<span class="op">);</span></span>
<span id="cb143-20"><a href="#cb143-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-21"><a href="#cb143-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb143-22"><a href="#cb143-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="ewise_intersection"><code>ewise_intersection</code></h2>
<p>Perform an element-wise intersection between two GraphBLAS matrices
or vectors.</p>
<h4 id="element-wise-matrix-intersection">Element-Wise Matrix
Intersection</h4>
<div class="sourceCode" id="cb144"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange A<span class="op">,</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a><span class="dt">ewise_intersection_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>ewise_intersection<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span> Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span>         <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>MatrixRange A<span class="op">,</span></span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb144-16"><a href="#cb144-16" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb144-17"><a href="#cb144-17" aria-hidden="true" tabindex="-1"></a>          MutableMatrixRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb144-18"><a href="#cb144-18" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb144-19"><a href="#cb144-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ewise_intersection<span class="op">(</span>C<span class="op">&amp;&amp;</span> c<span class="op">,</span> A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb144-20"><a href="#cb144-20" aria-hidden="true" tabindex="-1"></a>                        Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb144-21"><a href="#cb144-21" aria-hidden="true" tabindex="-1"></a>                        Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb144-22"><a href="#cb144-22" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span>                                 <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb144-23"><a href="#cb144-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-24"><a href="#cb144-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-25"><a href="#cb144-25" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb144-26"><a href="#cb144-26" aria-hidden="true" tabindex="-1"></a>          MatrixRange A<span class="op">,</span></span>
<span id="cb144-27"><a href="#cb144-27" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb144-28"><a href="#cb144-28" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb144-29"><a href="#cb144-29" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb144-30"><a href="#cb144-30" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;</span></span>
<span id="cb144-31"><a href="#cb144-31" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb144-32"><a href="#cb144-32" aria-hidden="true" tabindex="-1"></a><span class="dt">ewise_intersection_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;</span></span>
<span id="cb144-33"><a href="#cb144-33" aria-hidden="true" tabindex="-1"></a>ewise_intersection<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span></span>
<span id="cb144-34"><a href="#cb144-34" aria-hidden="true" tabindex="-1"></a>                   A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb144-35"><a href="#cb144-35" aria-hidden="true" tabindex="-1"></a>                   Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span>                       <span class="op">(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb144-36"><a href="#cb144-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-37"><a href="#cb144-37" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb144-38"><a href="#cb144-38" aria-hidden="true" tabindex="-1"></a>          MatrixRange A<span class="op">,</span></span>
<span id="cb144-39"><a href="#cb144-39" aria-hidden="true" tabindex="-1"></a>          MatrixRange B<span class="op">,</span></span>
<span id="cb144-40"><a href="#cb144-40" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb144-41"><a href="#cb144-41" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb144-42"><a href="#cb144-42" aria-hidden="true" tabindex="-1"></a>          MaskMatrixRange M <span class="op">=</span> grb<span class="op">::</span>full_matrix_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb144-43"><a href="#cb144-43" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb144-44"><a href="#cb144-44" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb144-45"><a href="#cb144-45" aria-hidden="true" tabindex="-1"></a>          MutableMatrixRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb144-46"><a href="#cb144-46" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb144-47"><a href="#cb144-47" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ewise_intersection<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span></span>
<span id="cb144-48"><a href="#cb144-48" aria-hidden="true" tabindex="-1"></a>                        C<span class="op">&amp;&amp;</span> c<span class="op">,</span> A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb144-49"><a href="#cb144-49" aria-hidden="true" tabindex="-1"></a>                        Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb144-50"><a href="#cb144-50" aria-hidden="true" tabindex="-1"></a>                        Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb144-51"><a href="#cb144-51" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span>                                 <span class="op">(</span><span class="dv">4</span><span class="op">)</span></span></code></pre></div>
<h4 id="element-wise-vector-intersection">Element-Wise Vector
Intersection</h4>
<div class="sourceCode" id="cb145"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange A<span class="op">,</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">&gt;</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a><span class="dt">ewise_intersection_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">,</span> M<span class="op">&gt;</span></span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a>ewise_intersection<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span> Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span>         <span class="op">(</span><span class="dv">5</span><span class="op">)</span></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>VectorRange A<span class="op">,</span></span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb145-12"><a href="#cb145-12" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb145-13"><a href="#cb145-13" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb145-14"><a href="#cb145-14" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb145-15"><a href="#cb145-15" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb145-16"><a href="#cb145-16" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb145-17"><a href="#cb145-17" aria-hidden="true" tabindex="-1"></a>          MutableVectorRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb145-18"><a href="#cb145-18" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb145-19"><a href="#cb145-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ewise_intersection<span class="op">(</span>C<span class="op">&amp;&amp;</span> c<span class="op">,</span> A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb145-20"><a href="#cb145-20" aria-hidden="true" tabindex="-1"></a>                        Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb145-21"><a href="#cb145-21" aria-hidden="true" tabindex="-1"></a>                        Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb145-22"><a href="#cb145-22" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span>                                 <span class="op">(</span><span class="dv">6</span><span class="op">)</span></span>
<span id="cb145-23"><a href="#cb145-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-24"><a href="#cb145-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-25"><a href="#cb145-25" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb145-26"><a href="#cb145-26" aria-hidden="true" tabindex="-1"></a>          VectorRange A<span class="op">,</span></span>
<span id="cb145-27"><a href="#cb145-27" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb145-28"><a href="#cb145-28" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb145-29"><a href="#cb145-29" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb145-30"><a href="#cb145-30" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;</span></span>
<span id="cb145-31"><a href="#cb145-31" aria-hidden="true" tabindex="-1"></a>          <span class="op">&gt;</span></span>
<span id="cb145-32"><a href="#cb145-32" aria-hidden="true" tabindex="-1"></a><span class="dt">ewise_intersection_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">,</span> M<span class="op">&gt;</span></span>
<span id="cb145-33"><a href="#cb145-33" aria-hidden="true" tabindex="-1"></a>ewise_intersection<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span></span>
<span id="cb145-34"><a href="#cb145-34" aria-hidden="true" tabindex="-1"></a>                   A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb145-35"><a href="#cb145-35" aria-hidden="true" tabindex="-1"></a>                   Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{});</span>                       <span class="op">(</span><span class="dv">7</span><span class="op">)</span></span>
<span id="cb145-36"><a href="#cb145-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-37"><a href="#cb145-37" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ExecutionPolicy<span class="op">,</span></span>
<span id="cb145-38"><a href="#cb145-38" aria-hidden="true" tabindex="-1"></a>          VectorRange A<span class="op">,</span></span>
<span id="cb145-39"><a href="#cb145-39" aria-hidden="true" tabindex="-1"></a>          VectorRange B<span class="op">,</span></span>
<span id="cb145-40"><a href="#cb145-40" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>A<span class="op">&gt;,</span></span>
<span id="cb145-41"><a href="#cb145-41" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">vector_scalar_t_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> Combine<span class="op">,</span></span>
<span id="cb145-42"><a href="#cb145-42" aria-hidden="true" tabindex="-1"></a>          MaskVectorRange M <span class="op">=</span> grb<span class="op">::</span>full_vector_mask<span class="op">&lt;&gt;,</span></span>
<span id="cb145-43"><a href="#cb145-43" aria-hidden="true" tabindex="-1"></a>          BinaryOperator<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span></span>
<span id="cb145-44"><a href="#cb145-44" aria-hidden="true" tabindex="-1"></a>                         grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> Accumulate <span class="op">=</span> grb<span class="op">::</span>take_right<span class="op">,</span></span>
<span id="cb145-45"><a href="#cb145-45" aria-hidden="true" tabindex="-1"></a>          MutableVectorRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">combine_result_t</span><span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> Combine<span class="op">&gt;&gt;</span> C</span>
<span id="cb145-46"><a href="#cb145-46" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span></span>
<span id="cb145-47"><a href="#cb145-47" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ewise_intersection<span class="op">(</span>ExecutionPolicy<span class="op">&amp;&amp;</span> policy<span class="op">,</span></span>
<span id="cb145-48"><a href="#cb145-48" aria-hidden="true" tabindex="-1"></a>                        C<span class="op">&amp;&amp;</span> c<span class="op">,</span> A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">,</span></span>
<span id="cb145-49"><a href="#cb145-49" aria-hidden="true" tabindex="-1"></a>                        Combine<span class="op">&amp;&amp;</span> combine<span class="op">,</span> M<span class="op">&amp;&amp;</span> mask <span class="op">=</span> M<span class="op">{},</span></span>
<span id="cb145-50"><a href="#cb145-50" aria-hidden="true" tabindex="-1"></a>                        Accumulate<span class="op">&amp;&amp;</span> acc <span class="op">=</span> Accumulate<span class="op">{},</span></span>
<span id="cb145-51"><a href="#cb145-51" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">bool</span> merge <span class="op">=</span> <span class="kw">false</span><span class="op">);</span>                                 <span class="op">(</span><span class="dv">8</span><span class="op">)</span></span></code></pre></div>
<p>Perform an element-wise intersection.</p>
<h3 id="parameters-46">Parameters</h3>
<p><code>policy</code> - the execution policy to use</p>
<p><code>a</code> - matrix or vector on the left-hand side of the
element-wise operation</p>
<p><code>b</code> - matrix or vector on the right-hand side of the
element-wise operation</p>
<p><code>c</code> - output matrix or vector in which to store the result
of the multiply operation</p>
<p><code>combine</code> - binary operator used to combine elements of
<code>a</code> and <code>b</code></p>
<p><code>mask</code> - determines which parts of the output matrix will
be computed</p>
<p><code>acc</code> - binary operator used to combine elements of the
result with stored elements in corresponding locations in
<code>c</code></p>
<p><code>merge</code> - flag declaring whether to merge in elements of
<code>c</code> outside the range indicated by <code>mask</code></p>
<h4 id="type-requirements-10">Type Requirements</h4>
<ul>
<li><p><code>A</code> must meet the requirements of
<code>MatrixRange</code> (1,2,3,4) or <code>VectorRange</code>
(5,6,7,8).</p></li>
<li><p><code>B</code> must meet the requirements of
<code>MatrixRange</code> (1,2,3,4) or <code>VectorRange</code>
(5,6,7,8).</p></li>
<li><p><code>C</code> must meet the requirements of
<code>MutableMatrixRange&lt;grb::combine_result_t&lt;A, B, Combine&gt;&gt;</code>
(2,4) or
<code>MutableVectorRange&lt;grb::combine_result_t&lt;A, B, Combine&gt;&gt;</code>
(6,8).</p></li>
<li><p><code>Combine</code> must meet the requirements of
<code>BinaryOperator&lt;grb::matrix_scalar_t&lt;A&gt;, grb::matrix_scalar_t&lt;B&gt;&gt;</code>
(1,2,3,4) or
<code>BinaryOperator&lt;grb::vector_scalar_t&lt;A&gt;, grb::vector_scalar_t&lt;B&gt;&gt;</code>
(5,6,7,8).</p></li>
<li><p><code>M</code> must meet the requirements of
<code>MaskMatrixRange</code> (1,2,3,4) or <code>MaskVectorRange</code>
(5,6,7,8).</p></li>
<li><p><code>Accumulate</code> must meet the requirements of
<code>BinaryOperator&lt;grb::matrix_scalar_t&lt;C&gt;, grb::combine_result_t&lt;A, B, Combine&gt;&gt;</code>
(2,4) or
<code>BinaryOperator&lt;grb::vector_scalar_t&lt;C&gt;, grb::combine_result_t&lt;A, B, Combine&gt;&gt;</code>
(6,8).</p></li>
</ul>
<h3 id="return-value-42">Return Value</h3>
<p>If the output matrix or vector parameter, <code>c</code>, is
supplied, no value is returned.</p>
<p>If the parameter <code>c</code> is not supplied, the function returns
a GraphBLAS matrix (1) or GraphBLAS vector (3) equal to the element-wise
intersection of <code>a</code> and <code>b</code>, with the binary
operator <code>combine</code> used to combine scalar values and
<code>mask</code> used to determine which parts of the output are
computed. For (1), the type of the return value satisfies the
requirements of <code>MatrixRange</code>, and for (3) the type of the
return value satisfies the requirements of <code>VectorRange</code>. The
return value has the same shape as <code>a</code> and <code>b</code>.
Index <code>idx</code> will only hold an element in the return value if
an element exists at <code>idx</code> in both <code>a</code>,
<code>b</code>, and <code>mask</code>, and the element of
<code>mask</code> holds a value equal to <code>true</code> when
converted to <code>bool</code>. The value at that index will be equal to
the value <code>fn(a[idx], b[idx])</code>.</p>
<h3 id="preconditions-1">Preconditions</h3>
<p>The parameters <code>a</code> and <code>b</code> must share the same
shape. If an output object <code>c</code> is given, it must also have
the same shape. For the parameter <code>mask</code>, each dimension of
its shape must be equal to or greater than the corresponding dimension
of <code>a</code> and <code>b</code>’s shapes. <code>fn</code> must not
modify any element of <code>a</code>, <code>b</code>, or
<code>mask</code>.</p>
<h3 id="postconditions-1">Postconditions</h3>
<p>In (2,4) and (6,8), an element-wise intersection is performed as
described in the <a
href="https://github.com/GraphBLAS/graphblas-api-math">GraphBLAS Math
Specification</a> and the result written to <code>c</code>. In (1,3) and
(5,7), none of the input arguments will be modified, and the result is
returned as a value.</p>
<h3 id="exceptions-18">Exceptions</h3>
<p>The exception <code>grb::invalid_argument</code> may be thrown if any
of the following conditions occur:</p>
<ul>
<li>The dimensions of <code>a</code> and <code>b</code> incompatible,
that is <code>a.shape() != b.shape()</code>.</li>
<li>The dimensions of <code>c</code>, if given, does not match
<code>a</code>’s shape, that is <code>c.shape() != a.shape()</code></li>
<li>The dimensions of the mask are smaller than the dimensions of the
output, that is
<code>mask.shape()[0] &lt; a.shape()[0] || mask.shape()[1] &lt; a.shape()[1]</code>
(1,2,3,4) or <code>mask.shape() &lt; a.shape()</code> (5,6,7,8).</li>
</ul>
<h3 id="notes-3">Notes</h3>
<h3 id="example-7">Example</h3>
<div class="sourceCode" id="cb146"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;grb/grb.hpp&gt;</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">**</span> argv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>matrix<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> x<span class="op">({</span><span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">});</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>matrix<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> y<span class="op">({</span><span class="dv">10</span><span class="op">,</span> <span class="dv">10</span><span class="op">});</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>  x<span class="op">[{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>  x<span class="op">[{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>  x<span class="op">[{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a>  x<span class="op">[{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true" tabindex="-1"></a>  y<span class="op">[{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true" tabindex="-1"></a>  y<span class="op">[{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true" tabindex="-1"></a>  y<span class="op">[{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb146-15"><a href="#cb146-15" aria-hidden="true" tabindex="-1"></a>  y<span class="op">[{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">}]</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb146-16"><a href="#cb146-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-17"><a href="#cb146-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> z <span class="op">=</span> grb<span class="op">::</span>ewise_intersection<span class="op">(</span>x<span class="op">,</span> y<span class="op">,</span> grb<span class="op">::</span>multiplies<span class="op">{});</span></span>
<span id="cb146-18"><a href="#cb146-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-19"><a href="#cb146-19" aria-hidden="true" tabindex="-1"></a>  grb<span class="op">::</span>print<span class="op">(</span>z<span class="op">);</span></span>
<span id="cb146-20"><a href="#cb146-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-21"><a href="#cb146-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb146-22"><a href="#cb146-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="assign"><code>assign</code></h2>
<div class="sourceCode" id="cb147"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>grb<span class="op">::</span>MatrixRange B<span class="op">,</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>          grb<span class="op">::</span>MutableMatrixRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">matrix_scalar_t</span><span class="op">&lt;</span>B<span class="op">&gt;&gt;</span> A<span class="op">&gt;</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assign<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span> B<span class="op">&amp;&amp;</span> b<span class="op">);</span>                                                   <span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> grb<span class="op">::</span>MutableMatrixRange A<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assign<span class="op">(</span>A<span class="op">&amp;&amp;</span> a<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> value<span class="op">);</span>                                          <span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>grb<span class="op">::</span>VectorRange V<span class="op">,</span></span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>          grb<span class="op">::</span>MutableVectorRange<span class="op">&lt;</span>grb<span class="op">::</span><span class="dt">vector_scalar_t</span><span class="op">&lt;</span>V<span class="op">&gt;</span> U<span class="op">&gt;</span></span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assign<span class="op">(</span>U<span class="op">&amp;&amp;</span> u<span class="op">,</span> V<span class="op">&amp;&amp;</span> v<span class="op">);</span>                                                   <span class="op">(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> grb<span class="op">::</span>MutableVectorRange V<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb147-15"><a href="#cb147-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> assign<span class="op">(</span>U<span class="op">&amp;&amp;</span> u<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> value<span class="op">);</span>                                          <span class="op">(</span><span class="dv">4</span><span class="op">)</span></span></code></pre></div>
<p>Assigns every element of a GraphbLAS matrix or vector to either (1,
3) another GraphBLAS matrix or vector with the same shape, or (2, 4) a
single scalar value.</p>
<h3 id="parameters-47">Parameters</h3>
<p><code>a</code> - the matrix to be assigned</p>
<p><code>b</code> - the matrix whose contents will be assigned to
<code>a</code></p>
<p><code>u</code> - the vector to be assigned</p>
<p><code>v</code> - the vector whose contents will be assigned to
<code>v</code></p>
<p><code>value</code> - a scalar value to be assigned to every index
location in <code>a</code></p>
<h4 id="type-requirements-11">Type Requirements</h4>
<ul>
<li><p><code>A</code> must be a mutable matrix range for the scalar
value being assigned, that is it must meet the requirements of
<code>grb::MutableMatrixRange&lt;grb::matrix_scalar_t&lt;B&gt;&gt;</code>
(1) or <code>grb::MutableMatrixRange&lt;T&gt;</code> (2)</p></li>
<li><p><code>B</code> must meet the requirements of
<code>grb::MatrixRange</code></p></li>
<li><p><code>U</code> must be a mutable vector range for the scalar
value being assigned, that is it must meet the requirements of
<code>grb::MutableVectorRange&lt;grb::vector_scalar_t&lt;V&gt;</code>
(3) or <code>grb::MutableVectorRange&lt;T&gt;</code> (4)</p></li>
<li><p><code>V</code> must meet the requirements of
<code>grb::VectorRange</code></p></li>
</ul>
<h3 id="exceptions-19">Exceptions</h3>
<p>The exception <code>grb::invalid_argument</code> is thrown if
<code>a</code> and <code>b</code> or <code>u</code> and <code>v</code>
are not the same shape. <code>std::bad_alloc</code> may be thrown if
<code>a</code> or <code>u</code>’s allocator is unable to allocate
memory.</p>
<p>Other exceptions may be thrown while assigning or constructing to
<code>a</code> or <code>u</code>.</p>
</body>
</html>
