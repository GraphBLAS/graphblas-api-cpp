\chapter{Functions}
\label{Chp:Functions}

A chapter for free functions that are not the GraphBLAS primitive operations.

%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------
\section{Views}

The C++ API specification supports a number of ``view'' types that wrap various
GraphBLAS containers (collections) to flag modifications of the collections
during calls to GraphBLAS functions.

%-----------------------------------------------------------------------------
\subsection{{\sf transpose}: Transpose view (input matrices only)}

Only for matrices.  
\scott{We do not need to specify the TransposeView class.  It is an
unspecified implementation detail.}

\paragraph{\syntax}

\begin{minted}{c++}
        template <typename MatrixType>
        /*unspecified*/ transpose(MatrixType const &mat);
\end{minted}

\scott{The "unspecified" style is taken from std::bind documentation: \\
https://en.cppreference.com/w/cpp/utility/functional/bind.  This allows it to be implementation dependent without specifying an auto return type.}

\paragraph{Parameters}

\begin{itemize}%[leftmargin=1.1in]
    \item[{\sf mat}] ({\sf IN}) A \emph{ConstMatrix}. A GraphBLAS Matrix object.  Will not be modified.
\end{itemize}

\paragraph{Return Value}

This method returns an object satisfying \emph{ConstMatrixView}.  The specific type is
implementation-dependent.

\paragraph{Description}

This function is intended to be used at the call site of GraphBLAS operations that take, 
as input, a GraphBLAS matrix that could be optionally transposed.  The function returns an
object that satisfies the \emph{ConstMatrixView} concept meaning it can only be used as an
{\sf IN} parameter that will not be modified.

\paragraph{Example}

\begin{minted}{c++}
        grb::Matrix A<float>({5, 10});
        grb::Matrix B<float>({5, 10});
        grb::Matrix C<float>({5, 5});
        // ...
        grb::mxm(C, grb::NoMask(), grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), A, transpose(B));
\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf structure}: Structure view (Masks (ConstContainers) only)}

Only for masks.  
\scott{We do not need to specify the StructureView class.  It is an
unspecified implementation detail.}

\paragraph{\syntax}

\begin{minted}{c++}
        template <typename MaskType>
        /*unspecified*/ structure(MaskType const &mask);
\end{minted}

\paragraph{Parameters}

\begin{itemize}%[leftmargin=1.1in]
    \item[{\sf mask}] ({\sf IN}) A GraphBLAS \emph{Mask} object. It is 
    overloaded to accept either a \emph{ConstMatrix} or \emph{ConstVector} 
    object.  The underlying object will not be modified.
\end{itemize}

\paragraph{Return Value}

This method returns an object satisfying a \emph{MaskView} (\emph{ConstMatrixView} or 
\emph{ConstVectorView}). If {\sf mask} is a \emph{ConstMatrix} type as input, 
it returns a \emph{ConstMatrixView}.  If {\sf mask} is a \emph{ConstVector} 
type as input, it returns a \emph{ConstVectorView}.  \scott{Do we need a specific
named requirement called MaskView?}

\paragraph{Description}

This function is intended to be used with masks at the call site of GraphBLAS 
operations that take, as input, a GraphBLAS matrix or vector mask.  The function 
returns an object that can be used by GraphBLAS operations that take a mask 
parameter as an {\sf IN} parameter (that will not be modified) and support the 
structure-only interpretation.

\paragraph{Example}

\begin{minted}{c++}
        grb::Matrix A<float>({5, 10});
        grb::Matrix B<float>({10, 5});
        grb::Matrix C<float>({5, 5});
        grb::Matrix M<bool>({5, 5});
        grb::Vector u<float>({10});
        grb::Vector w<float>({5});
        grb::Vector m<bool>({5});
        
        // ...
        grb::mxm(C, structure(M), grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), A, B);
        // ...
        grb::mxv(w, structure(m), grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), A, u);
\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf complement}: Complement view (Masks (ConstContainers) and MaskViews only)}

Only for masks.  
\scott{We do not need to specify the ComplementView class.  It is an
unspecified implementation detail.}

\paragraph{\syntax}

\begin{minted}{c++}
        template <typename MaskType>
        /*unspecified*/ complement(MaskType const &mask);
\end{minted}

\paragraph{Parameters}

\begin{itemize}%[leftmargin=1.1in]
    \item[{\sf mask}] ({\sf IN}) A GraphBLAS \emph{Mask} or a \emph{MaskView}
    object (specifically what is output by structure() method). It is 
    overloaded to accept either a \emph{ConstMatrix} or \emph{ConstVector} 
    objects or their respective structure views.  The underlying object will 
    not be modified.
\end{itemize}

\paragraph{Return Value}

This method returns an object satisfying a \emph{MaskView} (\emph{ConstMatrixView} or 
\emph{ConstVectorView}). If {\sf mask} is a \emph{ConstMatrix} or \emph{ConstMatrixView} type as input, 
it returns a \emph{ConstMatrixView}.  If {\sf mask} is a \emph{ConstVector} or  \emph{ConstVectorView}
type as input, it returns a \emph{ConstVectorView}.  \scott{Do we need a specific
named requirement called MaskView?}

\paragraph{Description}

This function is intended to be used with masks at the call site of GraphBLAS 
operations that take, as input, a GraphBLAS matrix or vector mask.  The function 
returns an object that can be used by GraphBLAS operations that take a mask 
parameter as an {\sf IN} parameter (that will not be modified) and support the 
interpretation of the complement of the object that is input to this method.

Unlike the {\sf structure()} function that can only accept \emph{ConstMatrix} or 
\emph{ConstVector}, this {\sf complement()} function must also be able to take as
input the object returned by {\sf structure()} to allow operations to support the
use of structural-complement masks (i.e., complements of the structure of a mask).

\paragraph{Examples}

\begin{minted}{c++}
        grb::Matrix A<float>({5, 10});
        grb::Matrix B<float>({10, 5});
        grb::Matrix C<float>({5, 5});
        grb::Matrix M<bool>({5, 5});
        grb::Vector u<float>({10});
        grb::Vector w<float>({5});
        grb::Vector m<bool>({5});
        // ...
        grb::mxm(C, complement(M), grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), A, B);
        // ...
        grb::mxm(C, complement(structure(M)), grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), A, B);
        // ...
        grb::mxv(w, complement(m), grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), A, u);
        // ...
        grb::mxv(w, complement(structure(m)), grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), A, u);

        // Does not compile:
        grb::mxv(w, structure(complement(m)), grb::NoAccumulate(), // ERROR
                 grb::PlusTimesSemiring<float>(), A, u);
\end{minted}
