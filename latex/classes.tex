\chapter{Classes}
\label{Chp:Classes}


This section defines the classes that correspond the GraphBLAS objects.

% ========================================================================
\section{Operators}

\scott{All callable objects must be supported, including <functional> and lambdas.}

\scott{There are no separate "Types".  UnaryOp and BinaryOps are all callable objects.  Monoids and Semirings are class templates}

Are the named requirements enough?

Give a few examples of functions, functors and lambdas  that can be used where a unaryop, binaryop, monoid and semiring are needed.

\subsection{Predefined operators}

\scott{Is there a set of the predefined operators? If so, list them.}

\subsection{\sf grb::NoAccumulate}

% ========================================================================
\section{Monoids}

Do we define the concept of a Monoid here.  We don't "new" them, rather they
are passed as templated arguments to the backend implementation.

\scott{Likely only structs, with operator() + identity()? Do we support result\_type?}

\subsection{Predefined monoids}


% ========================================================================
\section{Semirings}

Do we define the concept of a Semiring here.  We don't "new" them, rather they
are passed as templated arguments to the backend implementation.


\scott{likely only structs with add90, mult(), and zero().  Do we support 
first/second\_argument\_type and result\_type?}

\subsection{Predefined semirings}

% ========================================================================
\section{Sequences}
\label{Sec:Sequences}

There should be other sequences that replace "arrays of indices" that can also be substituted.

This is also important for distributed implementations where enumerating all indices in a range can be too large.

\subsection{Predefined sequences}

\subsection{\sf grb::AllIndices}

{\sf grb::AllIndices} a.k.a {\sf GrB\_ALL} is an example of a compact sequence.

% ========================================================================
\section{Vectors: {\sf grb::vector} class}
\label{Sec:Vectors}

This section defines the minimum required public interface to the "API"  Vector 
class.  It satisfies \textit{VectorCollection}?

\scott{Implementers free to add to the public API so long as the named requirement is still satisfied.}

Definition:

\begin{verbatim}
template <typename T,
          typename I = std::size_t,
          typename Hint = grb::bitmap_sparse,
          typename Allocator = std::allocator<T>>
class vector;
\end{verbatim}

\paragraph{Member Types}

\begin{tabularx}{\textwidth}{l X}
\textbf{Member Type} & \textbf{Definition}\\
\hline
\codet{value\_type} or \codet{ScalarType} & \codet{T}.  The type of elements stored in the Vector. \textit{CopyAssignable}. \textit{CopyConstructible} (pre C++11?) \scott{Here is the statement from the C++ Standard Graph Library proposal: "The graph value type defined by the user.  It can be most valid C++ value type including class, struct, tuple, union, enum, array, reference or scalar value. If no value is needed then the empty\_value struct can be used."}\\
\hline
\texttt{index\_type} or \texttt{IndexType} & \texttt{I}, \scott{Should we restrict this to unsigned integer types?} \\
\hline
\texttt{size\_type} & Unsigned integer type (usually \texttt{std::size\_t}).  \scott{For vector, size\_type and index\_type could be same.} \\
\hline
\texttt{difference\_type} & Signed integer type (usually \texttt{std::ptrdiff\_t})\\
\hline
\texttt{hint\_type} & \texttt{Hint}\\
\hline
\texttt{allocator\_type} & \texttt{Allocator}\\
\hline
\texttt{reference} & \textit{VectorReference} to \texttt{value\_type}\\
\hline
\texttt{const\_reference} & \textit{VectorReference} to \texttt{const value\_type}\\
\hline
\texttt{pointer} & \textit{VectorIterator} to \texttt{value\_type}\\
\hline
\texttt{const\_pointer} & \textit{VectorIterator} to \texttt{const value\_type}\\
\hline
\texttt{iterator} & \textit{VectorIterator} to \texttt{value\_type}\\
\hline
\texttt{const\_iterator} & \textit{Vectoriterator} to \texttt{const value\_type}\\
\end{tabularx}

\paragraph{Member functions}

\begin{tabularx}{\textwidth}{l X}
\textbf{Construct, assign, and move}\\
\hline
\texttt{vector()} & Construct empty vector of size $0$, \scott{Should we " = delete" this constructor?} \\ 
\hline
\texttt{vector(index\_type size)} & Construct vector of size $\texttt{size}$. \scott{should zero be disallowed...throw?} \\
& \texttt{panic\_exception} with unknown internal error \\
& \texttt{bad\_alloc} if not enough memory \\
& \texttt{invalid\_value} is size is zero. \\
\hline
\texttt{vector(std::string fname)} & Construct vector object from an \scott{XXX (what format?)} file at filepath \texttt{fname}.\\
\hline
\texttt{vector(const vector\& other)} & Copy construct vector from \texttt{other}.\\
\hline
\texttt{vector(vector\&\& other)} & Move construct vector from \texttt{other}.\\
\hline
\texttt{vector\& operator=(const vector\& other)} & Assignment operator from \texttt{other}. \scott{Check signature} \\
\hline
\texttt{vector\& operator=(vector\&\& other)} & Move assignment operator from \texttt{other} return state of \texttt{other} is implementation defined?. \scott{Check signature. is this noexcept?} \\
\hline
\texttt{\~{}vector()} & Destructor. Releases all resource held by the container within this object including all implementation data structures related to this object. \scott{Not virtual} \\
\end{tabularx}

\begin{tabularx}{\textwidth}{l X}
\textbf{Iterators}\\
\hline
\texttt{iterator begin()} & Non-const iterator to the beginning\\
\hline
\texttt{const\_iterator begin() const} & Const iterator to the beginning\\
\hline
\texttt{iterator end()} & Non-const iterator to the end\\
\hline
\texttt{const\_iterator end() const} & Const iterator to the end\\
\end{tabularx}

\begin{tabularx}{\textwidth}{l X}
\textbf{Capacity and Dimensions }\\
\hline
\texttt{size\_type reserve(size\_type capacity)} & \scott{(reserve not supported by opacity?)}\\
\hline
\texttt{size\_type capacity() const} & \scott{(capacity not supported by opacity?)}\\
\hline
\texttt{size\_type nvals() const} & Number of values stored in the vector (size()?)\\
\hline
\texttt{index\_type size() const} & Size of vector (dimension()?)\\
\hline
\texttt{index\_type resize(index\_type) new\_size)} & Size of vector (dimension()?)\\
\end{tabularx}

\begin{tabularx}{\textwidth}{l X}
\textbf{Lookup}\\
\hline
\texttt{reference at(index\_type index)} & Access specific element with bounds checking\\
\hline
\texttt{const\_reference at(index\_type index) const} & Access specific element with bounds checking\\
\hline
\texttt{reference operator[](index\_type index)} & Access or insert a specified element\\
\hline
\texttt{const\_reference operator[](index\_type index) const} & Access a specified element\\
\hline
\texttt{iterator find(index\_type index)} & Find element at a specific index\\
\hline
\texttt{const\_iterator find(index\_type index) const} & Find element at a specific index\\
\end{tabularx}

\begin{tabularx}{\textwidth}{l X}
\textbf{Other}\\
\hline
\texttt{iterator remove(index\_type index)} & Annihilate element at a specific index \scott{erase(ix)?} \\
\hline
\texttt{void clear()} &  \\
\hline
\texttt{void build(RAIndexIterator  i\_it,}  & container version?? \\
\texttt{~~~~~~~~~~~RAValueIterator  v\_it,}  & "not empty" exception?? index out of bounds exception?? \\
\texttt{~~~~~~~~~~~size\_type       nval,}  & ?? \\
\texttt{~~~~~~~~~~~BinaryOperator \&dup)}   & reference?? \\
\hline
\texttt{void build(vector<IndexType>  const \&indices,}  & const or move? bad sizes exception\\
\texttt{~~~~~~~~~~~vector<ScalarType> const \&values,}  & "not empty" exception?? index out of bounds exception?? \\
\texttt{~~~~~~~~~~~BinaryOperator \&dup)}   & reference?? \\
\hline
\texttt{void extractTuples()} & What is the C++ equivalent? \\
\texttt{void wait()} & What is the C++ equivalent? \\
\texttt{void error()} & What is the C++ equivalent? \\
\end{tabularx}

How should exceptions be documented?

\scott{Do we support void Scalar type for matrices and vectors?}

% ========================================================================
\section{Matrices: {\sf grb::matrix} class}
\label{Sec:Matrices}

\scott{define index\_t, shape\_t, location\_t, or whatever.}

Definition:

\begin{verbatim}
template <typename T,
          typename I = std::size_t,
          typename Hint = grb::sparse,
          typename Allocator = std::allocator<T>>
class matrix;
\end{verbatim}

\paragraph{Member Types}

\begin{tabularx}{\textwidth}{l X}
\textbf{Member Type} & \textbf{Definition}\\
\hline
\texttt{value\_type} & \texttt{T} \\
\hline
\texttt{index\_type} & \texttt{I} \\
\hline
\texttt{size\_type} & Unsigned integer type (usually \texttt{std::size\_t})\\
\hline
\texttt{difference\_type} & Signed integer type (usually \texttt{std::ptrdiff\_t})\\
\hline
\texttt{hint\_type} & \texttt{Hint}\\
\hline
\texttt{allocator\_type} & \texttt{Allocator}\\
\hline
\texttt{reference} & \textit{MatrixReference} to \texttt{value\_type}\\
\hline
\texttt{const\_reference} & \textit{MatrixReference} to \texttt{const value\_type}\\
\hline
\texttt{pointer} & \textit{MatrixIterator} to \texttt{value\_type}\\
\hline
\texttt{const\_pointer} & \textit{MatrixIterator} to \texttt{const value\_type}\\
\hline
\texttt{iterator} & \textit{MatrixIterator} to \texttt{value\_type}\\
\hline
\texttt{const\_iterator} & \textit{Matrixiterator} to \texttt{const value\_type}\\
\end{tabularx}

\paragraph{Member Functions}

\begin{tabularx}{\textwidth}{l X}
\hline
\codetlink{constructors}{(constructor)} & Construct the matrix object\\
\codetlink{constructors}{(destructor)} & Destruct the matrix object\\
\codetlink{assign_ops}{operator=} & Assign values to the matrix object\\
\end{tabularx}

\begin{tabularx}{\textwidth}{l X}
\textbf{Iterators}\\
\hline
\codetlink{iterators}{begin()} & Non-const iterator to the beginning\\
\hline
\codetlink{iterators}{end()} & Non-const iterator to the end\\
\end{tabularx}

\begin{tabularx}{\textwidth}{l X}
\textbf{Capacity and Dimensions}\\
\hline
\codetlink{capacity}{size()} & Number of stored values\\
\hline
\codetlink{capacity}{shape()} & Dimensions of matrix \scott{shape\_t}\\
\end{tabularx}

\begin{tabularx}{\textwidth}{l X}
\textbf{Lookup}\\
\texttt{reference at(index\_t index)} & Access specific element with bounds checking\\
\hline
\texttt{const\_reference at(index\_t index) const} & Access specific element with bounds checking\\
\hline
\texttt{reference operator[](index\_t index)} & Access or insert a specified element\\
\hline
\texttt{const\_reference operator[](index\_t index) const} & Access a specified element\\
\hline
\texttt{iterator find(index\_t index)} & Find element at a specific index\\
\hline
\texttt{const\_iterator find(index\_t index) const} & Find element at a specific index\\
\end{tabularx}

\scott{Do we support void Scalar type for matrices and vectors?}
\ben{I don't think we should.  It doesn't work with \codet{std::vector}, etc.  I would say define a \codet{grb::no\_value} or something.}

\subsection{Constructors and Destructors}
\hypertarget{constructors}{This section} defines constructors and destructors for \codet{grb::matrix}.

\begin{minted}{c++}
  matrix();                                      (1)

  matrix(grb::index_t dim);                      (2)

  matrix(std::string fname);                     (3)

  matrix(const matrix& other);                   (4)

  matrix(matrix&& other);                        (5)

  ~matrix();                                     (6)
\end{minted}

%\texttt{matrix()} & Construct empty matrix of dimension $0 \times 0$\\
%\hline
%\texttt{matrix(index\_t dim)} & Construct matrix of dimension $\texttt{dim[0]} \times \texttt{dim[1]}$\\
%\hline
%\texttt{matrix(\scott{shape\_t} dim)} & Construct matrix of dimension $\texttt{dim[0]} \times \texttt{dim[1]}$\\
%\hline
%\texttt{matrix(std::initializer\_list<{\color{red} index\_type}> dim)} & Construct matrix of dimension $\texttt{*dim.begin()} \times \texttt{*(++dim.begin)}$\\
%\hline
%\texttt{matrix(std::string fname)} & Construct matrix object from Matrix Market file \scott{(don't limit to MTX.)} at filepath \texttt{fname}.\\
%\hline
%\texttt{matrix(const matrix\& other)} & Copy construct matrix from \texttt{other}.\\
%\hline
%\texttt{matrix(matrix\&\& other)} & Move construct matrix from \texttt{other}.\\
%\texttt{\~{}matrix()} & Destructor. Releases all resource held by the container within this object including all implementation data structures related to this object. \scott{Not virtual} \\

\subsection{Assignment Operators}
\hypertarget{assign_ops}{This section} defines assignment operators for \codet{grb::matrix}.

\begin{minted}{c++}
  matrix& operator=(const matrix& other);        (1)

  matrix& operator=(matrix&& other);             (2)
\end{minted}

%\hline
%\texttt{matrix\& operator=(const matrix\& other)} & Copy assignment operator \texttt{other}.\\
%\hline
%\texttt{matrix\& operator=(matrix\&\& other)} & Move assignment operator \texttt{other}.\\
%\hline

\ben{Should we add assign to a matrix of a different type? (I think yes, with default casting.)  What about a view? (I also say yes, but you may not want to support it.)}

\ben{Should we add assign to a single element? (I think no, it's too ambiguous.)}

\subsection{Iterators}
\hypertarget{iterators}{This section} defines methods involving iterators for \codet{grb::matrix}.

\begin{minted}{c++}
  iterator begin();                              (1)

  const_iterator begin() const;                  (2)

  iterator end();                                (3)

  const_iterator end() const;                    (4)
\end{minted}

%\texttt{iterator begin()} & Non-const iterator to the beginning\\
%\hline
%\texttt{const\_iterator begin() const} & Const iterator to the beginning\\
%\hline
%\texttt{iterator end()} & Non-const iterator to the end\\
%\hline
%\texttt{const\_iterator end() const} & Const iterator to the end\\

\subsection{Capacity and Dimensions}
\hypertarget{capacity}{This section} defines methods involving capacity and dimensions for \codet{grb::matrix}.

\begin{minted}{c++}
  size_type size() const;                        (1)

  index_t shape() const;                         (2)
\end{minted}

%\texttt{size\_type size() const} & Number of stored values\\
%\hline
%\texttt{index\_t shape() const} & Dimensions of matrix \scott{shape\_t}\\

% ========================================================================
\section{Masks}
\label{Sec:Masks}



\subsection{\sf grb::NoMask}

There is a predefined object that satisfies \textit{VectorMask} and \textit{MatrixMask}
requirements that basically removes the use of a mask from the operation. It
is mathematically equivalent to sending in a "full" mask.
