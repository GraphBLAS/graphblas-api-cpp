\chapter{Basic Concepts}
\label{Chp:Concepts}

% ========================================================================
\section{Glossary}

\subsection{GraphBLAS API basic definitions}

\subsection{GraphBLAS objects and their structure}

\subsection{Algebraic structures used in the GraphBLAS}

Operators must comply with the style dictated for callables from {\sf <functional>} 
header file and lambdas.  Recommend C++14 approach that has deprecated use of {\sf result\_type}
typedefs and instead use
\begin{verbatim}
   decltype(binaryop(std::declval<typename LHS::ScalarType>(),
                     std::declval<typename RHS::ScalarType>()))
\end{verbatim}


GBTL demostrates how lambas and things like std::bind objects can be passed 
as arguments in place of UnaryOp and BinaryOp (they follow the Callable 
concept).  

Monoids and Semirings do not follow the Callable Concept.  These are
structs with methods not restricted to operator()().


\subsection{The execution of an application using the GraphBLAS C API}

\subsection{GraphBLAS methods: behaviors and error conditions}


% ========================================================================
\section{Notation}


% ========================================================================
\section{Algebraic and Arithmetic Foundations}


% ========================================================================
\section{GraphBLAS Opaque Objects}

Not GrB\_Type? (should not exist)\\
Not GrB\_Descriptor (does not exist)

While we have the concepts of UnaryOp, BinaryOp, Monoid, and Semiring we 
do not need to have such classes.  GBTL demostrates how lambas and things 
like std::bind objects can be passed as arguments in place of UnaryOp and
BinaryOp (they follow the Callable concept).  Monoids and Semirings do not 
follow the Callable Concept.

Right now only Vector and Matrix for sure.

There is a frontend Matrix and Vector class that take the place of C handles.

% ========================================================================
\section{Domains}


% ========================================================================
\section{Operators and Associated Functions}

While we have the concepts of UnaryOp, BinaryOp, Monoid, and Semiring we do not have such classes

See GBTL's {\sf algrebra.hpp} for demonstration of all "predefined" operators.


% ========================================================================
\section{Indices, Index Arrays, and Scalar Arrays}

Unlike the C API, GraphBLAS Vectors and Matrices in C++ can be templatized on
the index type and so can take on any unsigned integer type; therefore, there is
no equivalent to GrB\_Index.

Need to deal with mismatched index types?

% ========================================================================
\section{Execution Model}

\subsection{Execution modes}

\subsection{Thread safety}
\label{Sec:ThreadSafety}


% ========================================================================
\section{Error Model}
\label{Sec:ErrorModel}

Depending on support for execution models we may or may not have two 
categories of errors: API and execution errors.

All runtime errors are reported by throwing exceptions.  All exceptions generated
by the library inherit from {\sf grb::exception} that (in turn) inherits 
from {\sf std::exception}.

Exceptions subclassed from {\sf grb::exception}:

\begin{itemize}
\item {\sf logic\_error} base class for API errors.
    \begin{itemize}
    \item {\sf dimension\_mismatch}
    \end{itemize}
\item {\sf runtime\_error} base class for execution errors.
    \begin{itemize}
    \item {\sf panic\_error}
    \item {\sf bad\_alloc}... should we use {\sf std::bad\_alloc} instead?
    \item {\sf invalid\_object}
    \end{itemize}
\end{itemize}

% ========================================================================
\chapter{Named Requirements}
\label{Chp:NamedRequirements}

This section contains \textit{named requirements} describing the requirements for
various types to be used by the C++ GraphBLAS standard.
GraphBLAS implementations may choose to formalize these named requirements with
C++ concepts.  Regardless, C++ GraphBLAS implementers are responsible for
ensuring that their implementations comply with these named requirements, and
users who pass in custom objects to the GraphBLAS API are responsible for
ensuring that their types satisfy the corresponding named requirements.

% ========================================================================
\section{Binary Operators}
An object whose type fulfills the \textit{BinaryOperator} requirement is a C++
\textit{Callable} that can be called with two arguments, returning a single
value.  We call the type of the lefthand argument passed in to the binary operator
\texttt{T} and the type of the righthand argument \texttt{U}.  A callable is a
valid binary operator for types \texttt{T} and \texttt{U} if it is callable with
arguments of those types, returning an object of type \texttt{V}.

\begin{tabularx}{\textwidth}{l l X}
\textbf{Expression} & \textbf{Return Type} & \textbf{Requirements}\\
\hline
\texttt{binary\_op(T(), U())} & \texttt{V} & \texttt{binary\_op} is callable \texttt{T} $\times$ \texttt{U} $\rightarrow$ \texttt{V}.\\
\end{tabularx}

% ========================================================================
\section{Monoids}
An object whose type fulfills the \textit{Monoid} requirement is a callable that
fulfills the \textit{BinaryOperator} requirement in addition to two other requirements.
We say that an object is a monoid on type \texttt{T} if:

\begin{enumerate}
   \item The monoid is a valid \textit{BinaryOperator} on type \texttt{T} and has a return value of type \texttt{T}, \texttt{T} $\times$ \texttt{T} $\rightarrow$ \texttt{T}.
   \item The monoid has a method \texttt{identity} that is callable with template parameter \texttt{T}, returning an object of type \texttt{T} which is the identity for the binary operator on that type.
\end{enumerate}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Expression} & \textbf{Return Type} & \textbf{Requirements}\\
\hline
\texttt{monoid(T(), T())} & \texttt{T} & \texttt{monoid} is callable \texttt{T} $\times$ \texttt{T} $\rightarrow$ \texttt{T}.\\
\hline
\texttt{monoid.identity<T>()} & \texttt{T} & \texttt{identity()} method callable with template parameter \texttt{T}.\\
\end{tabularx}

% ========================================================================
\section{GraphBLAS Container? Matrix? Vector? Scalar?}

Not sure we need to define this.  Not sure we should have separate Matrix, Vector, 
and Scalar containters. I think these are the opaque data structures that implementers create.

\scott{Does something belong here or is it all in the containers section?}

\paragraph{Requirements}
\begin{itemize} \itemsep0em
\item \texttt{C} container type
\item \texttt{ScalarT} element type
\item \texttt{IndexT} indexing type (location of elements)
\end{itemize}

\paragraph{Types}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Name} & \textbf{Type} & \textbf{Notes}\\
\hline
\texttt{value\_type} & \texttt{ScalarT}  & Erasable?.\\ \hline
\texttt{reference}  & \texttt{ScalarT\&} & Do we need this? \\ \hline
\texttt{const\_reference}  & \texttt{const ScalarT\&} & Do we need this? \\ \hline
\texttt{iterator}  & & \\ \hline
\texttt{const\_iterator}  & & \\ \hline
\texttt{different\_type}  & & \\ \hline
\texttt{size\_type}  & &
\end{tabularx}

% ========================================================================
\section{MatrixView}
An object whose type fulfills the \textit{MatrixView} requirement is (loosely) a 
reference to an opaque \textit{GraphBLAS Container} that has two dimensions and a 
number of stored elements.  A \textit{GraphBLAS Container} is an object used to store
other objects, \textit{GraphBLAS Scalars}, that takes care of the management of the
memory used by these objects. \scott{Wording from C++ Container named requirements.}

\scott{Should the MatrixView only define enough interface to perform any runtime API error checks?}

\scott{Should MatrixView provide a reference to the internal container?}

\paragraph{Types}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Name} & \textbf{Type} & \textbf{Notes}\\
\hline
\texttt{value\_type} & \texttt{ScalarT}  & The type of objects stored in the container.\\ \hline
\texttt{index\_type} & \texttt{IndexT}   & Used to reference locations in the container \\ \hline
\texttt{size\_type}  & ??                & Can hold the number of elements stored in the container.
\end{tabularx}

\paragraph{Methods and operators}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Expression} & \textbf{Return Type} & \textbf{Requirements}\\
\hline
\texttt{nrows()} & \texttt{index\_type} & The size of the first dimension of the matrix.\\ \hline
\texttt{ncols()} & \texttt{index\_type} & The size of the second dimension of the matrix.\\ \hline
\texttt{nvals()} & \texttt{size\_type}  & The number of elements stored in the matrix. (not sure this is required)\\ \hline
constructors? & & \\
\end{tabularx}

% ========================================================================
\section{ConstMatrixView}

Is the same as a \textit{MatrixView} except that the opaque container within cannot be
mutated by calls to GraphBLAS operations.
