\chapter{Basic Concepts}
\label{Chp:Concepts}

% ========================================================================
\section{Glossary}

\subsection{GraphBLAS API basic definitions}

\subsection{GraphBLAS objects and their structure}

\subsection{Algebraic structures used in the GraphBLAS}

Operators must comply with the style dictated for callables from {\sf <functional>} 
header file and lambdas.  Recommend C++14 approach that has deprecated use of {\sf result\_type}
typedefs and instead use
\begin{verbatim}
   decltype(binaryop(std::declval<typename LHS::ScalarType>(),
                     std::declval<typename RHS::ScalarType>()))
\end{verbatim}


GBTL demostrates how lambas and things like std::bind objects can be passed 
as arguments in place of UnaryOp and BinaryOp (they follow the Callable 
concept).  

Monoids and Semirings do not follow the Callable Concept.  These are
structs with methods not restricted to operator()().


\subsection{The execution of an application using the GraphBLAS C API}

\subsection{GraphBLAS methods: behaviors and error conditions}


% ========================================================================
\section{Notation}


% ========================================================================
\section{Algebraic and Arithmetic Foundations}


No GraphBLAS method will imply a predefined order over any associative operators. Implementations of the GraphBLAS are encouraged to exploit associativity to optimize performance of any GraphBLAS method. This holds even if the definition of the GraphBLAS method implies a fixed order for the associative operations.

% ========================================================================
\section{GraphBLAS Opaque Objects}

Not GrB\_Type? (should not exist)\\
Not GrB\_Descriptor (does not exist)

While we have the concepts of UnaryOp, BinaryOp, Monoid, and Semiring we 
do not need to have such classes.  GBTL demostrates how lambas and things 
like std::bind objects can be passed as arguments in place of UnaryOp and
BinaryOp (they follow the Callable concept).  Monoids and Semirings do not 
follow the Callable Concept.

Right now only Vector and Matrix for sure. Don't think that GraphBLAS Scalar
is needed.

There is a frontend Matrix and Vector class that take the place of C handles.

% ========================================================================
\section{Domains}

Domains are tied to the ScalarType used for the Collections, and input and output
types of the algebraic types.  User-defined types (DefaultConstructible? Copyable and CopyAssignable) are supported as first class data types by the API.  Domains for these
types are dependent on the implementation.


% ========================================================================
\section{Operators and Associated Functions}

While we have the concepts of UnaryOp, BinaryOp, Monoid, and Semiring we do not have such classes

See GBTL's {\sf algrebra.hpp} for demonstration of all "predefined" operators.


% ========================================================================
\section{Indices, Index Arrays, and Scalar Arrays}

Unlike the C API, GraphBLAS Vectors and Matrices in C++ can be templatized on
the index type and so can take on any unsigned integer type; therefore, there is
no equivalent to GrB\_Index.

Need to deal with mismatched index types?

% ========================================================================
\section{Execution Model}

\subsection{Execution modes}

\subsection{Thread safety}

\subsection{Execution policies}


% ========================================================================
\section{Error Model and Exceptions}
\label{Sec:ErrorModel}

Depending on support for execution models we may or may not have two 
categories of errors: API and execution errors.

All runtime errors are reported by throwing exceptions.  All exceptions generated
by the library inherit from {\sf grb::exception} that (in turn) inherits 
from {\sf std::exception}.

Exceptions subclassed from {\sf grb::exception}:

\begin{itemize}
\item {\sf logic\_error} base class for API errors.
    \begin{itemize}
    \item {\sf dimension\_mismatch}
    \end{itemize}
\item {\sf runtime\_error} base class for execution errors.
    \begin{itemize}
    \item {\sf panic\_error}
    \item {\sf bad\_alloc}... should we use {\sf std::bad\_alloc} instead?
    \item {\sf invalid\_object}
    \end{itemize}
\end{itemize}
