% \mintinline{cpp}{code}
%=============================================================================
\chapter{GraphBLAS Operations}
\label{Ch:Operations}

%-----------------------------------------------------------------------------
\section{{\sf grb::mxm}: matrix-matrix multiply}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename CMatrixType,
             typename MaskType,
             typename AccumulatorType,
             typename SemiringType,
             typename AMatrixType,
             typename BMatrixType>
    void mxm(CMatrixType            &C,
             MaskType         const &Mask,
             AccumulatorType         accum,   // pass by value or const&?
             SemiringType            op,      // pass by value or const&?
             AMatrixType      const &A,
             BMatrixType      const &B,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);

    // ...or...
    template<typename CMatrixType,
             typename MaskType,
             typename AccumulatorType,
             typename ReduceType,
             typename MapType
             typename AMatrixType,
             typename BMatrixType>
    void mxm(CMatrixType            &C,
             MaskType         const &Mask,
             AccumulatorType         accum,   // pass by value or const&?
             ReduceType              reduce,  // pass by value or const&?
             MapType                 map,     // pass by value or const&?
             AMatrixType      const &A,
             BMatrixType      const &B,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);
\end{minted}

Multiplies two GraphBLAS matrices using the operators and identity defined by a GraphBLAS semiring. An optional accumulator and write mask can also be specified. The result is stored in third GraphBLAS matrix.

\begin{enumerate}
\item Any notes go here.
\end{enumerate}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) A GraphBLAS \emph{Matrix} type. On input,
    the matrix provides values that may be accumulated with the result of the
    matrix product.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask (a \emph{ConstMatrixView}) that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. 
    \scott{
    To complement/invert the logic of a mask, wrap the mask in a complement view by calling \code{grb::complement(Mask)}.
    To use the structure of this matrix only, wrap the mask in a structure view by calling \code{grb::structure(Mask)}.
    These views can be compose to get the complement of the structure of a mask by nesting these calls:
    \code{grb::complement(grb::structure(Mask))} (Note that \code{grb::structure(grb::complement(Mask))} is invalid and should not compile).
    If it is not wrapped in the \code{grb::structure} view, the domain 
    of the {\sf Mask} matrix must be of type that can be compared to \code{bool}.}
    If the default
    mask is desired (\ie, logically, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf grb::no\_mask} should be passed in for this argument.
    \scott{What should be passed?  \code{grb::no_mask} or \code{grb::NoMask()}}

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries.  If assignment rather than accumulation is
    desired, \code{grb::no_accum} should be specified. \scott{What should be passed?
    \code{grb::no_accum} or \code{grb::NoAccumulate()}}

    \item[{\sf op}]   ({\sf IN}) The semiring used in the matrix-matrix
    multiply.
    \scott{We could split this into two binary operators, map and reduce, one of which a monoid could be supplied.}

    \item[{\sf A}]    ({\sf IN}) The GraphBLAS matrix holding the values
    for the left-hand matrix in the multiplication.
    \scott{To used the transpose of a matrix, wrap this matrix in a transpose view by calling \code{grb::transpose(A)}.}

    \item[{\sf B}]    ({\sf IN}) The GraphBLAS matrix holding the values for
    the right-hand matrix in the multiplication.
    \scott{To used the transpose of a matrix, wrap this matrix in a transpose view by calling \code{grb::transpose(B)}.}

    \item[{\sf outp/replace\_flag}] ({\sf IN}) If a non-default mask (i.e. \code{grb::no_mask}) is specified,
    this flag controls what happens to the unmasked elements of the output.  If the flag is \code{true/grb::REPLACE}
    then the unmasked elements are cleared.  If the flag is \code{false/grb::MERGE}, the unmask elements are preserved in the final output. \\
\end{itemize}

\subparagraph{Type Requirements}

\begin{itemize}[leftmargin=1.1in]
    \item {\sf CMatrixType} must meet the requirements of a \textit{MatrixView}.  What are the basic matrix requirements?
    \item {\sf MaskType} must meet the requirements of a \emph{ConstMatrix} or (or is it \emph{Mask}: stored scalars must be convertible to bool) or \emph{MaskMatrixView}.  ComplementMatrixView or StructureMatrixView or StructuralComplementMatrixView, convertible to bool.  Range of index pairs denoting locations of the stored values)
    \item {\sf AMatrixType} and {\sf BMatrixType} must meet the requirements of a \emph{ConstMatrix} or \emph{ConstMatrixView}.
    \item {\sf AccumulatorType} must meet the requirements of a \emph{BinaryOperator}
    \item {\sf SemiringType} must meet the requirements of a \emph{GraphBLASSemiring}
\end{itemize}

If we decide to support breaking up the semiring into two parts without an identity then:

\begin{itemize}[leftmargin=1.1in]
    \item {\sf ReduceType} must meet the requirements of a \emph{CommutativeAssociativeBinaryOperator}
    \item {\sf MapType} must meet the requirements of a \emph{BinaryOperator}
\end{itemize}

Placeholder for named requirements:

\begin{itemize}
\item \emph{GraphBLASMatrix} - needs to satisfy the interface of a mutable GraphBLAS Matrix: nrows(), ncols(), nvals()
\item \emph{GraphBLASMaskMatrix} - A graphblas Matrix whose values are convertable to bool.
\item \emph{GraphBLASMatrixView} - Can provide a reference to a const GraphBLAS matrix
    \begin{itemize}
    \item \emph{GraphBLASMatrixComplementView}
    \item \emph{GraphBLASStructureMatrixView}
    \item \emph{GraphBLASStructuralComplementMatrixView}
    \item \emph{GraphBLASMatrixTransposeView}
    \end{itemize}
\item \emph{BinaryOperator}
\item \emph{GraphBLASSemiring} contains
    \begin{itemize}
    \item \emph{CommutativeAssociativeBinaryOperator}
    \item \emph{BinaryOperator}
    \end{itemize}
\end{itemize}

\begin{tabularx}{\textwidth}{X l}
Defined in header \texttt{<operations.hpp>}  &  \textbf{Notes} \\
\hline
\end{tabularx}

\paragraph{Return Values}

This function returns no values.  All errors result in exceptions being thrown.

\scott{There is a company that did not support exceptions and needed a return value semantic.  Do we change our philosophy to support.}

\paragraph{Exceptions}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf grb::panic\_error}]           (execution error, grb::runtime\_error) Unknown internal error.

    \item[{\sf grb::invalid\_object}] (execution error, runtime error) This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf grb::bad\_alloc}] (execution error, runtime error) Not enough memory available for the operation.
    \scott{is there a std::exception, std::bad\_alloc?}

    \item[{\sf grb::dimension\_mismatch}] (API error, logic error). Mask and/or matrix
    dimensions are incompatible. \scott{std::range\_error ?}
\end{itemize}

\paragraph{Blocking vs Non-Blocking Behaviour}

In blocking mode, the operation has completed successfully on return.
In non-blocking mode, this indicates that the compatibility 
tests on dimensions \scott{and domains for the input arguments passed successfully}. 
Either way, output matrix {\sf C} is ready to be used in the next method of
the sequence.

\paragraph{Description}

\scott{Does this specification need to the long duplicative mathematical descriptions
that are found in the C API Specification or can we refer to that spec here?}

\paragraph{Example}

\begin{minted}{c++}
        grb::Matrix A<float>({5, 10});
        grb::Matrix B<float>({5, 10});
        grb::Matrix C<float>({5, 5});
        grb::Matrix M<bool>({5, 5});
        // ...
        grb::mxm(C, M, grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), A, B,
                 grb::MERGE);
        // ...
        // using all possible matrix views
        grb::mxm(C, complement(structure(M)), grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), transpose(A), transpose(B),
                 grb::REPLACE);
\end{minted}

%-----------------------------------------------------------------------------
\section{{\sf grb::multiply}: Matrix-matrix multiply alternative form}

\paragraph{\syntax}

\begin{verbatim}
    // consider an additional form
    template<typename AMatrixType,
             typename BMatrixType,
             typename SemiringType,
             typename MaskType=grb::NoMask>
    auto multiply(AMatrixType const &A, BMatrixType const &B,
                  SemiringType semiring_op, MaskType const &Mask=MaskType());  // const& ?
\end{verbatim}

%-----------------------------------------------------------------------------
\section{{\sf mxv}: matrix-vector multiply}

\paragraph{\syntax}

\begin{minted}{c++}
    // overload using a semiring
    template<typename WVectorType,
             typename MaskType,
             typename AccumulatorType,
             typename SemiringType,
             typename AMatrixType,
             typename BMatrixType>
    void mxv(WVectorType            &w,
             MaskType         const &mask,
             AccumulatorType         accum,   // pass by value or const&?
             SemiringType            op,      // pass by value or const&?
             AMatrixType      const &A,
             UVectorType      const &u,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);

    // ...or...overload using two binary operators
    template<typename WVectorType,
             typename MaskType,
             typename AccumulatorType,
             typename ReduceType,
             typename MapType,
             typename AMatrixType,
             typename UVectorType>
    void mxv(WVectorType            &w,
             MaskType         const &mask,
             AccumulatorType         accum,   // pass by value or const&?
             ReduceType              reduce,  // pass by value or const&?
             MapType                 map,     // pass by value or const&?
             AMatrixType      const &A,
             UVectorType      const &u,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);
\end{minted}

%-----------------------------------------------------------------------------
\section{{\sf vxm}: vector-matrix multiply}

\paragraph{\syntax}

\begin{minted}{c++}
    // overload using a semiring
    template<typename WVectorType,
             typename MaskType,
             typename AccumulatorType,
             typename SemiringType,
             typename UVectorType,
             typename AMatrixType>
    void vxm(WVectorType            &w,
             MaskType         const &mask,
             AccumulatorType         accum,   // pass by value or const&?
             SemiringType            op,      // pass by value or const&?
             UVectorType      const &u,
             AMatrixType      const &A,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);

    // ...or...overload using two binary operators
    template<typename WVectorType,
             typename MaskType,
             typename AccumulatorType,
             typename ReduceType,
             typename MapType,
             typename UVectorType,
             typename AMatrixType>
    void vxm(WVectorType            &w,
             MaskType         const &mask,
             AccumulatorType         accum,   // pass by value or const&?
             ReduceType              reduce,  // pass by value or const&?
             MapType                 map,     // pass by value or const&?
             UVectorType      const &u,
             AMatrixType      const &A,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);
\end{minted}


%-----------------------------------------------------------------------------
\section{{\sf ewisemult}: element-wise multiplication, set intersection}

\paragraph{\syntax}

\begin{minted}{c++}
    // grb::vector overload
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumType,
             typename BinaryOpType,
             typename UVectorType,
             typename VVectorType>
    void ewisemult(vector<T, I, Hint, Allocator>     &w,
                   MaskType                    const &mask,
                   AccumType                   const &accum,
                   BinaryOpType                       op,
                   UVectorType                 const &u,
                   VVectorType                 const &v,
                   OutputControlEnum                  outp = MERGE);  // default val?

    // grb::matrix overload
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumType,
             typename BinaryOpType,
             typename AMatrixType,
             typename BMatrixType>
    void ewisemult(matrix<T, I, Hint, Allocator>     &C,
                   MaskT                       const &Mask,
                   AccumT                      const &accum,
                   BinaryOpT                          op,
                   AMatrixT                    const &A,
                   BMatrixT                    const &B,
                   OutputControlEnum                  outp = MERGE);  // default val?
\end{minted}


%-----------------------------------------------------------------------------
\section{{\sf ewiseadd}: element-wise addition}

\paragraph{\syntax}

\begin{minted}{c++}
    // grb::vector overload
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumType,
             typename BinaryOpType,
             typename UVectorType,
             typename VVectorType>
    void ewiseadd(vector<T, I, Hint, Allocator>     &w,
                  MaskType                    const &mask,
                  AccumType                   const &accum,
                  BinaryOpType                       op,
                  UVectorType                 const &u,
                  VVectorType                 const &v,
                  OutputControlEnum                  outp = MERGE);  // default val?

    // grb::matrix overload
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumType,
             typename BinaryOpType,
             typename AMatrixType,
             typename BMatrixType>
    void ewiseadd(matrix<T, I, Hint, Allocator>     &C,
                  MaskT                       const &Mask,
                  AccumT                      const &accum,
                  BinaryOpT                          op,
                  AMatrixT                    const &A,
                  BMatrixT                    const &B,
                  OutputControlEnum                  outp = MERGE);  // default val?
\end{minted}


%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------
\subsection{{\sf extract}: }

%-----------------------------------------------------------------------------
\subsection{{\sf extract}: standard vector variant}

\paragraph{\syntax}

\begin{minted}{c++}
    // standard grb::vector variant
    template<typename WVectorType,     // typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumType,
             typename UVectorType,
             typename SequenceType>
    void extract(WVectorType             &w,  // should we use vector<T, I, Hint, Allocator>?
                 MaskType          const &mask,
                 AccumType         const &accum,
                 UVectorType       const &u,
                 SequenceType      const &indices,
                 OutputControlEnum        outp = MERGE);  // default val?
\end{minted}

%-----------------------------------------------------------------------------
\subsection{{\sf extract}: standard matrix variant}

\paragraph{\syntax}

\begin{minted}{c++}
    // standard grb::matrix variant
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumType,
             typename AMatrixType,
             typename RowSequenceType,
             typename ColSequenceType>
    void extract(matrix<T, I, Hint, Allocator>  &C,
                 MaskT                    const &mask,
                 AccumT                   const &accum,
                 AMatrixT                 const &A,
                 RowSequenceT             const &row_indices,
                 ColSequenceT             const &col_indices,
                 OutputControlEnum               outp = MERGE);  // default val?
\end{minted}

%-----------------------------------------------------------------------------
\subsection{{\sf extract}: column (row) variant}

\paragraph{\syntax}

\begin{minted}{c++}
    // standard grb::matrix variant
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumType,
             typename AMatrixType,
             typename RowSequenceType>
    void extract(vector<T, I, Hint, Allocator>  &w,
                 MaskT                    const &mask,
                 AccumT                   const &accum,
                 AMatrixT                 const &A,
                 RowSequenceT             const &row_indices,
                 index_t                         col_index,
                 OutputControlEnum               outp = MERGE);  // default val?
\end{minted}


%-----------------------------------------------------------------------------
\section{{\sf assign}: }

%-----------------------------------------------------------------------------
\subsection{{\sf assign}: standard vector variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskT,
             typename AccumT,
             typename UVectorT,
             typename SequenceT,
             typename std::enable_if_t<is_vector_v<UVectorT>, int> = 0,
             typename ...WTags>
    void assign(vector<T, I, Hint, Allocator>      &w,
                MaskT                    const  &mask,
                AccumT                   const  &accum,
                UVectorT                 const  &u,
                SequenceT                const  &indices,
                OutputControlEnum                outp = MERGE)
\end{minted}

%-----------------------------------------------------------------------------
\subsection{{\sf assign}: standard matrix variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename CMatrixT, // it isn't enough to do T, I, Hint, Allocator
             typename MaskT,
             typename AccumT,
             typename AMatrixT,
             typename RowSequenceT,
             typename ColSequenceT,
             typename std::enable_if_t<is_matrix_v<AMatrixT>, int> = 0>
    inline void assign(CMatrixT              &C,
                       MaskT           const &Mask,
                       AccumT          const &accum,
                       AMatrixT        const &A,
                       RowSequenceT    const &row_indices,
                       ColSequenceT    const &col_indices,
                       OutputControlEnum      outp = MERGE)
\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf assign}: column variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename CScalarT,
             typename MaskT,
             typename AccumT,
             typename UVectorT,
             typename SequenceT,
             typename ...CTags>
    inline void assign(Matrix<CScalarT, CTags...>  &C,
                       MaskT                 const &mask,  // a vector
                       AccumT                const &accum,
                       UVectorT              const &u,
                       SequenceT             const &row_indices,
                       IndexType                    col_index,
                       OutputControlEnum            outp = MERGE)
\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf assign}: row variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename CScalarT,
             typename MaskT,
             typename AccumT,
             typename UVectorT,
             typename SequenceT,
             typename ...CTags>
    inline void assign(Matrix<CScalarT, CTags...>  &C,
                       MaskT                 const &mask,  // a vector
                       AccumT                const &accum,
                       UVectorT              const &u,
                       IndexType                    row_index,
                       SequenceT             const &col_indices,
                       OutputControlEnum            outp = MERGE)
\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf assign}: vector constant variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename WVectorT,
             typename MaskT,
             typename AccumT,
             typename ValueT,
             typename SequenceT,
             typename std::enable_if<
                 std::is_convertible<ValueT,
                                     typename WVectorT::ScalarType>::value,
                 int>::type = 0>
    inline void assign(WVectorT                     &w,
                       MaskT                const   &mask,
                       AccumT               const   &accum,
                       ValueT                        val,
                       SequenceT            const   &indices,
                       OutputControlEnum             outp = MERGE)
\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf assign}: matrix constant variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename CMatrixT,
             typename MaskT,
             typename AccumT,
             typename ValueT,
             typename RowSequenceT,
             typename ColSequenceT,
             typename std::enable_if<
                 std::is_convertible<ValueT,
                                     typename CMatrixT::ScalarType>::value,
                 int>::type = 0>
    inline void assign(CMatrixT             &C,
                       MaskT          const &Mask,
                       AccumT         const &accum,
                       ValueT                val,
                       RowSequenceT   const &row_indices,
                       ColSequenceT   const &col_indices,
                       OutputControlEnum     outp = MERGE)
\end{minted}



%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------
\subsection{{\sf apply}: }

\paragraph{\syntax}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf select}: }

\paragraph{\syntax}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf reduce}: }

\paragraph{\syntax}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf transpose}: }

\paragraph{\syntax}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf kronecker}: }

\paragraph{\syntax}

\begin{minted}{c++}

\end{minted}

