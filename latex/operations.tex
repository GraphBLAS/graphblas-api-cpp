% \mintinline{cpp}{code}
%=============================================================================
\chapter{GraphBLAS Operations}
\label{Ch:Operations}

%-----------------------------------------------------------------------------
\section{{\sf grb::mxm}: matrix-matrix multiply}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename CMatrixType,
             typename MaskType,
             typename AccumulatorType,
             typename SemiringType,
             typename AMatrixType,
             typename BMatrixType>
    void mxm(CMatrixType            &C,
             MaskType         const &Mask,
             AccumulatorType         accum,   // pass by value or const&?
             SemiringType            op,      // pass by value or const&?
             AMatrixType      const &A,
             BMatrixType      const &B,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);

    // ...or...
    template<typename CMatrixType,
             typename MaskType,
             typename AccumulatorType,
             typename ReduceType,
             typename MapType
             typename AMatrixType,
             typename BMatrixType>
    void mxm(CMatrixType            &C,
             MaskType         const &Mask,
             AccumulatorType         accum,   // pass by value or const&?
             ReduceType              reduce,  // pass by value or const&?
             MapType                 map,     // pass by value or const&?
             AMatrixType      const &A,
             BMatrixType      const &B,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);
\end{minted}

Multiplies two GraphBLAS matrices using the operators and identity defined by a GraphBLAS semiring. An optional accumulator and write mask can also be specified. The result is stored in third GraphBLAS matrix.

\begin{enumerate}
\item Any notes go here.
\end{enumerate}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) A GraphBLAS \emph{Matrix} type. On input,
    the matrix provides values that may be accumulated with the result of the
    matrix product.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask (a \emph{ConstMatrixView}) that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. 
    \scott{
    To complement/invert the logic of a mask, wrap the mask in a complement view by calling \code{grb::complement(Mask)}.
    To use the structure of this matrix only, wrap the mask in a structure view by calling \code{grb::structure(Mask)}.
    These views can be compose to get the complement of the structure of a mask by nesting these calls:
    \code{grb::complement(grb::structure(Mask))} (Note that \code{grb::structure(grb::complement(Mask))} is invalid and should not compile).
    If it is not wrapped in the \code{grb::structure} view, the domain 
    of the {\sf Mask} matrix must be of type that can be compared to \code{bool}.}
    If the default
    mask is desired (\ie, logically, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf grb::no\_mask} should be passed in for this argument.
    \scott{What should be passed?  \code{grb::no_mask} or \code{grb::NoMask()}}

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries.  If assignment rather than accumulation is
    desired, \code{grb::no_accum} should be specified. \scott{What should be passed?
    \code{grb::no_accum} or \code{grb::NoAccumulate()}}

    \item[{\sf op}]   ({\sf IN}) The semiring used in the matrix-matrix
    multiply.
    \scott{We could split this into two binary operators, map and reduce, one of which a monoid could be supplied.}

    \item[{\sf A}]    ({\sf IN}) The GraphBLAS matrix holding the values
    for the left-hand matrix in the multiplication.
    \scott{To used the transpose of a matrix, wrap this matrix in a transpose view by calling \code{grb::transpose(A)}.}

    \item[{\sf B}]    ({\sf IN}) The GraphBLAS matrix holding the values for
    the right-hand matrix in the multiplication.
    \scott{To used the transpose of a matrix, wrap this matrix in a transpose view by calling \code{grb::transpose(B)}.}

    \item[{\sf outp/replace\_flag}] ({\sf IN}) If a non-default mask (i.e. \code{grb::no_mask}) is specified,
    this flag controls what happens to the unmasked elements of the output.  If the flag is \code{true/grb::REPLACE}
    then the unmasked elements are cleared.  If the flag is \code{false/grb::MERGE}, the unmask elements are preserved in the final output. \\
\end{itemize}

\subparagraph{Type Requirements}

\begin{itemize}[leftmargin=1.1in]
    \item {\sf CMatrixType} must meet the requirements of a \textit{MatrixView}.  What are the basic matrix requirements?
    \item {\sf MaskType} must meet the requirements of a \emph{ConstMatrix} or (or is it \emph{Mask}: stored scalars must be convertible to bool) or \emph{MaskMatrixView}.  ComplementMatrixView or StructureMatrixView or StructuralComplementMatrixView, convertible to bool.  Range of index pairs denoting locations of the stored values)
    \item {\sf AMatrixType} and {\sf BMatrixType} must meet the requirements of a \emph{ConstMatrix} or \emph{ConstMatrixView}.
    \item {\sf AccumulatorType} must meet the requirements of a \emph{BinaryOperator}
    \item {\sf SemiringType} must meet the requirements of a \emph{GraphBLASSemiring}
\end{itemize}

If we decide to support breaking up the semiring into two parts without an identity then:

\begin{itemize}[leftmargin=1.1in]
    \item {\sf ReduceType} must meet the requirements of a \emph{CommutativeAssociativeBinaryOperator}
    \item {\sf MapType} must meet the requirements of a \emph{BinaryOperator}
\end{itemize}

Placeholder for named requirements:

\begin{itemize}
\item \emph{GraphBLASMatrix} - needs to satisfy the interface of a mutable GraphBLAS Matrix: nrows(), ncols(), nvals()
\item \emph{GraphBLASMaskMatrix} - A graphblas Matrix whose values are convertable to bool.
\item \emph{GraphBLASMatrixView} - Can provide a reference to a const GraphBLAS matrix
    \begin{itemize}
    \item \emph{GraphBLASMatrixComplementView}
    \item \emph{GraphBLASStructureMatrixView}
    \item \emph{GraphBLASStructuralComplementMatrixView}
    \item \emph{GraphBLASMatrixTransposeView}
    \end{itemize}
\item \emph{BinaryOperator}
\item \emph{GraphBLASSemiring} contains
    \begin{itemize}
    \item \emph{CommutativeAssociativeBinaryOperator}
    \item \emph{BinaryOperator}
    \end{itemize}
\end{itemize}

\begin{tabularx}{\textwidth}{X l}
Defined in header \texttt{<operations.hpp>}  &  \textbf{Notes} \\
\hline
\end{tabularx}

\paragraph{Return Values}

This function returns no values.  All errors result in exceptions being thrown.

\scott{There is a company that did not support exceptions and needed a return value semantic.  Do we change our philosophy to support.}

\paragraph{Exceptions}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf grb::panic\_error}]           (execution error, grb::runtime\_error) Unknown internal error.

    \item[{\sf grb::invalid\_object}] (execution error, runtime error) This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf grb::bad\_alloc}] (execution error, runtime error) Not enough memory available for the operation.
    \scott{is there a std::exception, std::bad\_alloc?}

    \item[{\sf grb::dimension\_mismatch}] (API error, logic error). Mask and/or matrix
    dimensions are incompatible. \scott{std::range\_error ?}
\end{itemize}

\paragraph{Blocking vs Non-Blocking Behaviour}

In blocking mode, the operation has completed successfully on return.
In non-blocking mode, this indicates that the compatibility 
tests on dimensions \scott{and domains for the input arguments passed successfully}. 
Either way, output matrix {\sf C} is ready to be used in the next method of
the sequence.

\paragraph{Description}

\scott{Does this specification need to the long duplicative mathematical descriptions
that are found in the C API Specification or can we refer to that spec here?}

\paragraph{Example}

\begin{minted}{c++}
        grb::Matrix A<float>({5, 10});
        grb::Matrix B<float>({5, 10});
        grb::Matrix C<float>({5, 5});
        grb::Matrix M<bool>({5, 5});
        // ...
        grb::mxm(C, M, grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), A, B,
                 grb::MERGE);
        // ...
        // using all possible matrix views
        grb::mxm(C, grb::complement(grb::structure(M)), grb::NoAccumulate(), 
                 grb::PlusTimesSemiring<float>(), grb::transpose(A), grb::transpose(B),
                 grb::REPLACE);

        // the alternate map-reduce form
        // using all possible matrix views
        grb::mxm(C, grb::complement(grb::structure(M)), grb::NoAccumulate(), 
                 grb::Plus<float>(), grb::Times<float>(),
                 grb::transpose(A), grb::transpose(B),
                 grb::REPLACE);

        // the alternate map-reduce form using lambdas
        // using all possible matrix views
        grb::mxm(C, grb::complement(grb::structure(M)), grb::NoAccumulate(), 
                 [&](auto const &c1, auto const &c2) { return c1 + c2; }, // reducer
                 [&](auto const &a,  auto const &b)  { return a * b; },   // mapper
                 grb::transpose(A), grb::transpose(B),
                 grb::REPLACE);
                
\end{minted}

%-----------------------------------------------------------------------------
\section{{\sf grb::multiply}: Matrix-matrix multiply alternative form}

\paragraph{\syntax}

\begin{verbatim}
    // consider an additional form
    template<typename AMatrixType,
             typename BMatrixType,
             typename SemiringType,
             typename MaskType=grb::NoMask>
    auto multiply(AMatrixType const &A, BMatrixType const &B,
                  SemiringType semiring_op, MaskType const &Mask=MaskType());  // const& ?
\end{verbatim}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}

%-----------------------------------------------------------------------------
\section{{\sf mxv}: matrix-vector multiply}

\paragraph{\syntax}

\begin{minted}{c++}
    // overload using a semiring
    template<typename WVectorType,
             typename MaskType,
             typename AccumulatorType,
             typename SemiringType,
             typename AMatrixType,
             typename BMatrixType>
    void mxv(WVectorType            &w,
             MaskType         const &mask,
             AccumulatorType         accum,   // pass by value or const&?
             SemiringType            op,      // pass by value or const&?
             AMatrixType      const &A,
             UVectorType      const &u,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);

    // ...or...overload using two binary operators
    template<typename WVectorType,
             typename MaskType,
             typename AccumulatorType,
             typename ReduceType,
             typename MapType,
             typename AMatrixType,
             typename UVectorType>
    void mxv(WVectorType            &w,
             MaskType         const &mask,
             AccumulatorType         accum,   // pass by value or const&?
             ReduceType              reduce,  // pass by value or const&?
             MapType                 map,     // pass by value or const&?
             AMatrixType      const &A,
             UVectorType      const &u,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}

%-----------------------------------------------------------------------------
\section{{\sf vxm}: vector-matrix multiply}

\paragraph{\syntax}

\begin{minted}{c++}
    // overload using a semiring
    template<typename WVectorType,
             typename MaskType,
             typename AccumulatorType,
             typename SemiringType,
             typename UVectorType,
             typename AMatrixType>
    void vxm(WVectorType            &w,
             MaskType         const &mask,
             AccumulatorType         accum,   // pass by value or const&?
             SemiringType            op,      // pass by value or const&?
             UVectorType      const &u,
             AMatrixType      const &A,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);

    // ...or...overload using two binary operators
    template<typename WVectorType,
             typename MaskType,
             typename AccumulatorType,
             typename ReduceType,
             typename MapType,
             typename UVectorType,
             typename AMatrixType>
    void vxm(WVectorType            &w,
             MaskType         const &mask,
             AccumulatorType         accum,   // pass by value or const&?
             ReduceType              reduce,  // pass by value or const&?
             MapType                 map,     // pass by value or const&?
             UVectorType      const &u,
             AMatrixType      const &A,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\section{{\sf ewisemult}: element-wise multiplication, set intersection}

\paragraph{\syntax}

\begin{minted}{c++}
    // grb::vector overload
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename BinaryOpType,
             typename UVectorType,
             typename VVectorType>
    void ewisemult(vector<T, I, Hint, Allocator>     &w,
                   MaskType                    const &mask,
                   AccumulatorType                          accum,
                   BinaryOpType                       op,
                   UVectorType                 const &u,
                   VVectorType                 const &v,
                   OutputControlEnum                  outp = MERGE);  // default val?

    // grb::matrix overload
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename BinaryOpType,
             typename AMatrixType,
             typename BMatrixType>
    void ewisemult(matrix<T, I, Hint, Allocator>     &C,
                   MaskT                       const &Mask,
                   AccumulatorT                             accum,
                   BinaryOpType                          op,
                   AMatrixT                    const &A,
                   BMatrixT                    const &B,
                   OutputControlEnum                  outp = MERGE);  // default val?
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\section{{\sf ewiseadd}: element-wise addition}

\paragraph{\syntax}

\begin{minted}{c++}
    // grb::vector overload
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename BinaryOpType,
             typename UVectorType,
             typename VVectorType>
    void ewiseadd(vector<T, I, Hint, Allocator>     &w,
                  MaskType                    const &mask,
                  AccumulatorType                          accum,
                  BinaryOpType                       op,
                  UVectorType                 const &u,
                  VVectorType                 const &v,
                  OutputControlEnum                  outp = MERGE);  // default val?

    // grb::matrix overload
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename BinaryOpType,
             typename AMatrixType,
             typename BMatrixType>
    void ewiseadd(matrix<T, I, Hint, Allocator>     &C,
                  MaskT                       const &Mask,
                  AccumulatorT                             accum,
                  BinaryOpType                          op,
                  AMatrixT                    const &A,
                  BMatrixT                    const &B,
                  OutputControlEnum                  outp = MERGE);  // default val?
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------
\subsection{{\sf extract}: }

%-----------------------------------------------------------------------------
\subsection{{\sf extract}: standard vector variant}

\paragraph{\syntax}

\begin{minted}{c++}
    // standard grb::vector variant
    template<typename WVectorType,     // typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename UVectorType,
             typename SequenceType>
    void extract(WVectorType             &w,  // should we use vector<T, I, Hint, Allocator>?
                 MaskType          const &mask,
                 AccumulatorType                accum,
                 UVectorType       const &u,
                 SequenceType      const &indices,
                 OutputControlEnum        outp = MERGE);  // default val?
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}

%-----------------------------------------------------------------------------
\subsection{{\sf extract}: standard matrix variant}

\paragraph{\syntax}

\begin{minted}{c++}
    // standard grb::matrix variant
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename AMatrixType,
             typename RowSequenceType,
             typename ColSequenceType>
    void extract(matrix<T, I, Hint, Allocator>  &C,
                 MaskType                 const &mask,
                 AccumulatorT                    accum,
                 AMatrixT                 const &A,
                 RowSequenceT             const &row_indices,
                 ColSequenceT             const &col_indices,
                 OutputControlEnum               outp = MERGE);  // default val?
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}

%-----------------------------------------------------------------------------
\subsection{{\sf extract}: column (row) variant}

\paragraph{\syntax}

\begin{minted}{c++}
    // standard grb::matrix variant
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename AMatrixType,
             typename RowSequenceType>
    void extract(vector<T, I, Hint, Allocator>     &w,
                 MaskType                    const &mask,
                 AccumulatorT                       accum,
                 AMatrixT                    const &A,
                 RowSequenceT                const &row_indices,
                 typename AMatrixType::index_type   col_index,      // size_t?
                 OutputControlEnum                  outp = MERGE);  // default val?
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\section{{\sf assign}: }

\scott{We need a sequence name requirement that is either an index array, 
range of indices, and/or some other iterable that e.g. could be specified with
[begin:stride:end)}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf assign}: standard vector variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename UVectorType,
             typename SequenceType,
             typename std::enable_if_t<is_vector_v<UVectorType>, int> = 0> //???
    void assign(vector<T, I, Hint, Allocator>   &w,
                MaskType                 const  &mask,
                AccumulatorType                  accum,
                UVectorType              const  &u,
                SequenceType             const  &indices,
                OutputControlEnum                outp = MERGE);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}

%-----------------------------------------------------------------------------
\subsection{{\sf assign}: standard matrix variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename CMatrixType, // isn't enough to do T, I, Hint, Allocator
             typename MaskType,
             typename AccumulatorType,
             typename AMatrixType,
             typename RowSequenceType,
             typename ColSequenceType,
             typename std::enable_if_t<is_matrix_v<AMatrixType>, int> = 0>
    void assign(CMatrixType              &C,
                MaskType           const &Mask,
                AccumulatorType           accum,
                AMatrixType        const &A,
                RowSequenceType    const &row_indices,
                ColSequenceType    const &col_indices,
                OutputControlEnum         outp = MERGE);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf assign}: column variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename UVectorType,
             typename SequenceType>
    void assign(matrix<T, I, Hint, Allocator>  &C,
                MaskType                 const &mask,  // a vector
                AccumulatorType                 accum,
                UVectorType              const &u,
                SequenceType             const &row_indices,
                I                               col_index,   // size_t?
                OutputControlEnum               outp = MERGE)
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf assign}: row variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename UVectorType,
             typename SequenceType>
    void assign(matrix<T, I, Hint, Allocator>  &C,
                MaskType                 const &mask,  // a vector
                AccumulatorType                 accum,
                UVectorType              const &u,
                I                            row_index,  // size_t?
                SequenceType             const &col_indices,
                OutputControlEnum            outp = MERGE)
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf assign}: vector constant variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename WVectorType,
             typename MaskType,
             typename AccumulatorType,
             typename ValueType,
             typename SequenceType,
             typename std::enable_if<
                 std::is_convertible<ValueType,
                                     typename WVectorType::ScalarType>::value,
                 int>::type = 0>
    void assign(WVectorType                     &w,
                MaskType                const   &mask,
                AccumulatorType                accum,
                ValueType                        val,
                SequenceType            const   &indices,
                OutputControlEnum                outp = MERGE)
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf assign}: matrix constant variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename CMatrixType,
             typename MaskType,
             typename AccumulatorType,
             typename ValueType,
             typename RowSequenceType,
             typename ColSequenceType,
             typename std::enable_if<
                 std::is_convertible<ValueType,
                                     typename CMatrixType::ScalarType>::value,
                 int>::type = 0>
    void assign(CMatrixType             &C,
                MaskType          const &Mask,
                AccumulatorType          accum,
                ValueType                val,
                RowSequenceType   const &row_indices,
                ColSequenceType   const &col_indices,
                OutputControlEnum        outp = MERGE)
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}



%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------
\section{{\sf apply}}

\scott{Separate binary op + constant variants not necessary.  What to do about apply(i)}

%-----------------------------------------------------------------------------
\subsection{{\sf apply}: vector variants}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename UnaryOpType,
             typename UVectorType>
    void apply(vector<T, I, Hint, Allocator>  &w,
               MaskType                 const &mask,
               AccumulatorType                 accum,
               UnaryOpType                     op,
               UVectorType              const &u,
               OutputControlEnum               outp = MERGE);

    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename IndexUnaryOpType,
             typename UVectorType>
    void apply(vector<T, I, Hint, Allocator>  &w,
               MaskType                 const &mask,
               AccumulatorType                 accum,
               IndexUnaryOpType                op,
               ValueType                const &s
               UVectorType              const &u,
               OutputControlEnum               outp = MERGE);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}
        // take the absolute value of all stored elements using predefined unary op
        grb::apply(u, grb::NoMask(), grb::NoAccumulate(),
                   grb::abs<float>(),
                   s);

        // using a lamba to multiply each stored value by a random number
        std::default_random_engine             generator;
        std::uniform_real_distribution<double> distribution;
        grb::apply(p, grb::NoMask(), grb::NoAccumulate(),
                   [&](bool tval)      //set_random,
                   {
                       return static_cast<RealT>(
                           tval*distribution(generator) + 0.0001);
                   },
                   t);

        // Adapting a binary operator to multiply all elements of m by scalar damping_factor
        grb::apply(m, grb::NoMask(), grb::NoAccumulate(),
                   std::bind(grb::times<RealT>(),
                             std::placeholders::_1,
                             damping_factor),
                   m);
                   
        // Using an index unary operator to replace all elements with their row index
        grb::apply(ri, grb::NoMask(), grb::NoAccumulate(),
                   grb::row_index<m::value_type>(),   // TODO predefined signature 
                   0UL,
                   m);
\end{minted}

%-----------------------------------------------------------------------------
\subsection{{\sf apply}: matrix variants}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename UnaryOpType,
             typename AMatrixType>
    void apply(matrix<T, I, Hint, Allocator>  &C,
               MaskType                 const &Mask,
               AccumulatorType                 accum,
               UnaryOpType                     op,
               AMatrixType              const &A,
               OutputControlEnum               outp = MERGE);

    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename IndexUnaryOpType,
             typename AMatrixType>
    void apply(matrix<T, I, Hint, Allocator>  &C,
               MaskType                 const &Mask,
               AccumulatorType                 accum,
               IndexUnaryOpType                op,
               ValueType                const &s
               AMatrixType              const &A,
               OutputControlEnum               outp = MERGE);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}
        // take the absolute value of all stored elements using predefined unary op
        grb::apply(U, grb::NoMask(), grb::NoAccumulate(),
                   grb::abs<float>(),
                   S);

        // using a lamba to multiply each stored value by a random number
        std::default_random_engine             generator;
        std::uniform_real_distribution<double> distribution;
        grb::apply(P, grb::NoMask(), grb::NoAccumulate(),
                   [&](bool tval)      //set_random,
                   {
                       return static_cast<RealT>(
                           tval*distribution(generator) + 0.0001);
                   },
                   T);

        // Adapting a binary operator to multiply all elements of m by scalar damping_factor
        grb::apply(M, grb::NoMask(), grb::NoAccumulate(),
                   std::bind(grb::times<RealT>(),
                             std::placeholders::_1,
                             damping_factor),
                   M);
                   
        // Using an index unary operator to replace all elements with their row index
        grb::apply(Ri, grb::NoMask(), grb::NoAccumulate(),
                   grb::row_index<m::value_type>(),   // TODO predefined signature 
                   0UL,
                   M);

\end{minted}


%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------
\section{{\sf select}: }

\scott{is there such thing as a graphblas scalar? Do we build the scalar into the operator or add it to the parameter list?}

%-----------------------------------------------------------------------------
\subsection{{\sf select}: vector variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename UnaryOpType,
             typename UVectorType>
    void select(vector<T, I, Hint, Allocator>  &w,
                MaskType                 const &mask,
                AccumulatorType                 accum,
                IndexUnaryOpType                op,
                ValueType                const &s
                UVectorType              const &u,
                OutputControlEnum               outp = MERGE);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf select}: matrix variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename T, typename I, typename Hint, typename Allocator,
             typename MaskType,
             typename AccumulatorType,
             typename UnaryOpType,
             typename AMatrixType>
    void select(matrix<T, I, Hint, Allocator>  &C,
                MaskType                 const &Mask,
                AccumulatorType                 accum,
                IndexUnaryOpType                op,
              //ValueType                const &thunk
                AMatrixType              const &A,
                OutputControlEnum               outp = MERGE);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------
\section{{\sf reduce}}


%-----------------------------------------------------------------------------
\subsection{{\sf reduce}: row reduce matrix-to-vector variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename WVectorType,
             typename MaskType,
             typename AccumulatorType,
             typename BinaryOpType,  // monoid or binary op only
             typename AMatrixType>
    void reduce(WVectorType          &w,
                MaskType       const &mask,
                AccumulatorType       accum,
                BinaryOpType          op,
                AMatrixType    const &A,
                OutputControlEnum     outp = MERGE);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf reduce}: vector-to-scalar variant}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename ValueType,
             typename AccumulatorType,
             typename MonoidType, // monoid only?
             typename T, typename I, typename Hint, typename Allocator>
    void reduce(ValueType                            &val,
                AccumulatorType                       accum,
                MonoidType                            op,
                vector<T, I, Hint, Allocator>  const &u);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\subsection{{\sf reduce}: matrix-to-scalar variant}

\scott{C API spec says that we do not need to support transpose of input.}

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename ValueType,
             typename AccumulatorType,
             typename MonoidType, // monoid only?
             typename T, typename I, typename Hint, typename Allocator>
    void reduce(ValueType                            &val,
                AccumulatorType                       accum,
                MonoidType                            op,
                matrix<T, I, Hint, Allocator>  const &A);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\section{{\sf transpose}: }

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename CMatrixType,
             typename MaskType,
             typename AccumulatorType,
             typename AMatrixType>
    void transpose(CMatrixType          &C,
                   MaskType       const &Mask,
                   AccumulatorType       accum,
                   AMatrixType    const &A,
                   OutputControlEnum     outp = MERGE);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}


%-----------------------------------------------------------------------------
\section{{\sf kronecker}: }

\paragraph{\syntax}

\begin{minted}{c++}
    template<typename CMatrixType,
             typename MaskType,
             typename AccumulatorType,
             typename BinaryOpType,
             typename AMatrixType,
             typename BMatrixType>
    void kronecker(CMatrixType          &C,
                   MaskType       const &Mask,
                   AccumulatorType       accum,
                   BinaryOpType          op,
                   AMatrixType    const &A,
                   BMatrixType    const &B,
                   OutputControlEnum     outp = MERGE);
\end{minted}


\paragraph{Example}

\begin{minted}{c++}

\end{minted}

