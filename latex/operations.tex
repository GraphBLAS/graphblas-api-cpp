
%=============================================================================
\chapter{GraphBLAS Operations}

%-----------------------------------------------------------------------------
\section{{\sf grb::multiply}: Matrix-matrix multiply}

\paragraph{\syntax}

\begin{verbatim}
    // consider an additional form
    template<typename AMatrixType,
             typename BMatrixType,
             typename SemiringType,
             typename MaskType=grb::NoMask>
    auto multiply(AMatrixType const &A, BMatrixType const &B,
                  SemiringType semiring_op, MaskType const &Mask=MaskType());  // const& ?
\end{verbatim}

%-----------------------------------------------------------------------------
\section{{\sf grb::mxm}: Matrix-matrix multiply}

\paragraph{\syntax}

\begin{verbatim}
    template<typename CMatrixType,
             typename MaskType,
             typename AccumulatorType,
             typename SemiringType,
             typename AMatrixType,
             typename BMatrixType>
    void mxm(CMatrixType            &C,
             MaskType         const &Mask,
             AccumulatorType  const &accum,
             SemiringType            op,         // pass by value or ref? const?
             AMatrixType      const &A,
             BMatrixType      const &B,
             OutputControlEnum       outp = MERGE);  //or bool replace_flag = false);
\end{verbatim}

Multiplies two GraphBLAS matrices using the operators and identity defined by a GraphBLAS semiring. An optional accumulator and write mask can also be specified. The result is stored in third GraphBLAS matrix.

\begin{enumerate}
\item Any notes go here.
\item The "additional" form creates a new output matrix to hold the result.  Accumulation is not supported.
\end{enumerate}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) A GraphBLAS matrix. On input,
    the matrix provides values that may be accumulated with the result of the
    matrix product.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask (a GraphBLAS matrix) that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. 
    \scott{
    To complement/invert the logic of a mask, wrap the mask in a complement view by calling {\sf grb::complement(Mask)}.
    To use the structure of this matrix only, wrap the mask in a structure view by calling {\sf grb::structure(Mask)}.
    These views can be compose to get the complement of the structure of a mask by nesting these calls:
    {\sf grb::complement(grb::structure(Mask))} (Note that grb::structure(grb::complement(Mask)) is invalid and should not compile).
    If it is not wrapped in the {\sf grb::structure} view, the domain 
    of the {\sf Mask} matrix must be of type that can be compared to {\sf bool}.}
    If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf grb::no\_mask} should be passed in for this argument.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries.  If assignment rather than accumulation is
    desired, {\sf grb::no\_accum} should be specified.

    \item[{\sf op}]   ({\sf IN}) The semiring used in the matrix-matrix
    multiply.
    \scott{We could split this into two binary operators, map and reduce, one of which a monoid could be supplied.}

    \item[{\sf A}]    ({\sf IN}) The GraphBLAS matrix holding the values
    for the left-hand matrix in the multiplication.
    \scott{To used the transpose of a matrix, wrap this matrix in a transpose view by calling {\sf grb::transpose(A)}.}

    \item[{\sf B}]    ({\sf IN}) The GraphBLAS matrix holding the values for
    the right-hand matrix in the multiplication.
    \scott{To used the transpose of a matrix, wrap this matrix in a transpose view by calling {\sf grb::transpose(B)}.}

    \item[{\sf outp/replace\_flag}] ({\sf IN}) If a non-default mask (i.e. {\sf grb::no\_mask}) is specified,
    this flag controls what happens to the unmasked elements of the output.  If the flag is {\sf true/grb::REPLACE}
    then the unmasked elements are cleared.  If the flag is {\sf false/grb::MERGE}, the unmask elements are preserved in the final output. \\
\end{itemize}

\subparagraph{Type Requirements}

\begin{itemize}[leftmargin=1.1in]
    \item {\sf CMatrixType} must meet the requirements of a \textit{MatrixView}.  What are the basic matrix requirements?
    \item {\sf MaskType} must meet the requirements of a \emph{GraphBLASMatrix} (or is it \emph{GraphBLASMaskMatrix}: stored scalars must be convertible to bool) or \emph{GraphBLASMatrixComplementView} (convertible to bool) or \emph{GraphBLASStructureMatrixView} (range of index pairs denoting locations of the stored values) or  \emph{GraphBLASStructuralComplementMatrixView}..
    \item {\sf AMatrixType} and {\sf BMatrixType} must meet the requirements of a const \textit{ConstMatrixView}.
    \item {\sf AccumulatorType} must meet the requirements of a \emph{BinaryOperator}
    \item {\sf SemiringType} must meet the requirements of a \emph{GraphBLASSemiring}
    \item {\sf ReduceType} must meet the requirements of a \emph{CommutativeAssociativeBinaryOperator}
    \item {\sf MapType} must meet the requirements of a \emph{BinaryOperator}
\end{itemize}

Placeholder for named requirements:

\begin{itemize}
\item \emph{GraphBLASMatrix} - needs to satisfy the interface of a mutable GraphBLAS Matrix: nrows(), ncols(), nvals()
\item \emph{GraphBLASMaskMatrix} - A graphblas Matrix whose values are convertable to bool.
\item \emph{GraphBLASMatrixView} - Can provide a reference to a const GraphBLAS matrix
    \begin{itemize}
    \item \emph{GraphBLASMatrixComplementView}
    \item \emph{GraphBLASStructureMatrixView}
    \item \emph{GraphBLASStructuralComplementMatrixView}
    \item \emph{GraphBLASMatrixTransposeView}
    \end{itemize}
\item \emph{BinaryOperator}
\item \emph{GraphBLASSemiring}
    \begin{itemize}
    \item \emph{CommutativeAssociativeBinaryOperator}
    \item \emph{BinaryOperator}
    \end{itemize}
\end{itemize}

\begin{tabularx}{\textwidth}{X l}
Defined in header \texttt{<operations.hpp>}  &  \textbf{Notes} \\
\hline
\end{tabularx}

\paragraph{Return Values}

This function returns no values.  All errors result in exceptions being thrown.

\scott{There is a company that did not support exceptions and needed a return value semantic.}

\paragraph{Exceptions}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf grb::panic\_error}]           (execution error, grb::runtime\_error) Unknown internal error.

    \item[{\sf grb::invalid\_object}] (execution error, runtime error) This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf grb::bad\_alloc}] (execution error, runtime error) Not enough memory available for the operation.
    \scott{is there a std::exception, std::bad\_alloc?}

    \item[{\sf grb::dimension\_mismatch}] (API error, logic error). Mask and/or matrix
    dimensions are incompatible. \scott{std::range\_error ?}
\end{itemize}

\paragraph{Blocking vs Non-Blocking Behaviour}

In blocking mode, the operation has completed successfully on return.
In non-blocking mode, this indicates that the compatibility 
tests on dimensions \scott{and domains for the input arguments passed successfully}. 
Either way, output matrix {\sf C} is ready to be used in the next method of
the sequence.

\paragraph{Description}

%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------
\section{Older stuff}

%-----------------------------------------------------------------------------
\subsection{{\sf mxv}: Matrix-vector multiply}

\subsection{{\sf vxm}: Vector-matrix multiply}


%-----------------------------------------------------------------------------
\subsection{{\sf ewisemult}: }

%-----------------------------------------------------------------------------
\subsection{{\sf ewiseadd}: }

%-----------------------------------------------------------------------------
\subsection{{\sf extract}: }

%-----------------------------------------------------------------------------
\subsection{{\sf assign}: }

%-----------------------------------------------------------------------------
\subsection{{\sf apply}: }

%-----------------------------------------------------------------------------
\subsection{{\sf select}: }

%-----------------------------------------------------------------------------
\subsection{{\sf reduce}: }

%-----------------------------------------------------------------------------
\subsection{{\sf transpose}: }

%-----------------------------------------------------------------------------
\subsection{{\sf kronecker}: }
