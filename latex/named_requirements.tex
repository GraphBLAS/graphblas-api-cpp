% ========================================================================
\chapter{Named Requirements}
\label{Chp:NamedRequirements}

This section contains \textit{named requirements} describing the requirements for
various types to be used by the C++ GraphBLAS standard.
GraphBLAS implementations may choose to formalize these named requirements with
C++ concepts.  Regardless, C++ GraphBLAS implementers are responsible for
ensuring that their implementations comply with these named requirements, and
users who pass in custom objects to the GraphBLAS API are responsible for
ensuring that their types satisfy the corresponding named requirements.

% ========================================================================
\section{Unary Operators}

% ========================================================================
\section{Index Unary Operators}

% ========================================================================
\section{Binary Operators}
An object whose type fulfills the \textit{BinaryOperator} requirement is a C++
\textit{Callable} that can be called with two arguments, returning a single
value.  We call the type of the lefthand argument passed in to the binary operator
\code{T} and the type of the righthand argument \code{U}.  A callable is a
valid binary operator for types \code{T} and \code{U} if it is callable with
arguments of those types, returning an object of type \code{V}.

\begin{tabularx}{\textwidth}{l l X}
\textbf{Expression} & \textbf{Return Type} & \textbf{Requirements}\\
\hline
\texttt{binary\_op(T(), U())} & \texttt{V} & \texttt{binary\_op} is callable \texttt{T} $\times$ \texttt{U} $\rightarrow$ \texttt{V}.\\
\end{tabularx}

% ========================================================================
\section{Monoids}
An object whose type fulfills the \textit{Monoid} requirement is a callable that
fulfills the \textit{BinaryOperator} requirement in addition to two other requirements.
We say that an object is a monoid on type \code{T} if:

\begin{enumerate}
   \item The monoid is a valid \textit{BinaryOperator} on type \texttt{T} and has a return value of type \texttt{T}, \texttt{T} $\times$ \texttt{T} $\rightarrow$ \texttt{T}.
   \item The monoid has a method \texttt{identity} that is callable with template parameter \texttt{T}, returning an object of type \texttt{T} which is the identity for the binary operator on that type.
\end{enumerate}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Expression} & \textbf{Return Type} & \textbf{Requirements}\\
\hline
\texttt{monoid(T(), T())} & \texttt{T} & \texttt{monoid} is callable \texttt{T} $\times$ \texttt{T} $\rightarrow$ \texttt{T}.\\
\hline
\texttt{monoid.identity<T>()} & \texttt{T} & \texttt{identity()} method callable with template parameter \texttt{T}.\\
\end{tabularx}

% ========================================================================
\section{Matrix}

\paragraph{Types}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Name} & \textbf{Notes}\\
\hline
\texttt{value\_type} & Type of value stored in matrix .\\ \hline
\texttt{index\_type} & Type used to store indices.\\ \hline
\texttt{size\_type}  & Unsigned integer type, usually \texttt{std::size\_t} \\ \hline
\texttt{difference\_type}  & Signed integer type, usually \texttt{std::ptrdiff\_t} \\ \hline
\texttt{reference} & Reference type\\ \hline
\texttt{const\_reference}  & Const reference type\\ \hline
\texttt{iterator}  & Iterator type\\ \hline
\texttt{const\_iterator}  & Const iterator type\\ \hline
\end{tabularx}

\ben{I think we should basically add all the ``functionality'' methods of grb::matrix here.}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Expression} & \textbf{Return Type} & \textbf{Requirements}\\
\hline
\texttt{matrix.shape()} & \idxname & Has method \texttt{shape()}, returning shape of matrix.\\
\texttt{matrix.size()} & \texttt{size\_type} & Has method \texttt{size()}, returning number of values.\\
\end{tabularx}

% ========================================================================
\section{GraphBLAS Container? Matrix? Vector? Scalar?}

Not sure we need to define this.  Not sure we should have separate Matrix, Vector, 
and Scalar containers. I think these are the opaque data structures that implementers create.

\scott{Does something belong here or is it all in the containers section?}

\paragraph{Requirements}
\begin{itemize} \itemsep0em
\item \texttt{C} container type
\item \texttt{ScalarT} element type
\item \texttt{IndexT} indexing type (location of elements)
\end{itemize}

\paragraph{Types}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Name} & \textbf{Type} & \textbf{Notes}\\
\hline
\texttt{value\_type} & \texttt{ScalarT}  & Erasable?.\\ \hline
\texttt{reference}  & \texttt{ScalarT\&} & Do we need this? \\ \hline
\texttt{const\_reference}  & \texttt{const ScalarT\&} & Do we need this? \\ \hline
\texttt{iterator}  & & \\ \hline
\texttt{const\_iterator}  & & \\ \hline
\texttt{different\_type}  & & \\ \hline
\texttt{size\_type}  & &
\end{tabularx}

% ========================================================================
\section{MatrixView}
An object whose type fulfills the \textit{MatrixView} requirement provides a
non-const view of a GraphBLAS matrix.
%reference to an opaque \textit{GraphBLAS Container} that has two dimensions and a 
%number of stored elements.  A \textit{GraphBLAS Container} is an object used to store
%other objects, \textit{GraphBLAS Scalars}, that takes care of the management of the
%memory used by these objects. \scott{Wording from C++ Container named requirements.}

\scott{Should the MatrixView only define enough interface to perform any runtime API error checks?}
\ben{That's basically the idea, but I don't think we necessarily need to mandate that here?}

\scott{Should MatrixView provide a reference to the internal container?}
\ben{I don't think so. In full generality, there potentially might not be an underlying matrix to reference. We only want to specify the \textit{publicly visible} API here, and we don't necessarily need to give users the underlying matrix.}

\paragraph{Types}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Type} & \textbf{Notes}\\
\hline
\texttt{value\_type} & The type of objects stored in the container.\\ \hline
\texttt{index\_type} & Type used to index into the container \\ \hline
\texttt{size\_type}  & Unsigned integer type (usually \texttt{std::size\_t}). \\ \hline
(implementation defined) & & Implementations are free to include other requirements.
\end{tabularx}

\paragraph{Methods and operators}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Expression} & \textbf{Return Type} & \textbf{Requirements}\\
\hline
\texttt{view.shape()} & \idxname & The shape of the matrix\\ \hline
\texttt{view.size()} & \texttt{size\_type}& The number of elements stored in the matrix. \scott{this is not required}\\
(implementation defined) & & Implementations are free to include other requirements.
\end{tabularx}

\ben{No constructors, since IMO the only valid way for a user to get a view should be e.g. \texttt{grb::transpose} fn.}

A \emph{Matrix} object is a valid \emph{MatrixView} object

% ========================================================================
\section{ConstMatrixView}

% ========================================================================
A \textit{ConstMatrixView} fulfills the same requirements as \textit{MatrixView}, but it may not be used in GraphBLAS operations where it would be modified.

\section{Structure Views}
% ========================================================================
\section{MatrixStructureView}
A \textit{MatrixStructureView} fulfills the same requirements as \textit{MatrixView}.  However, it may be used as the agument to certain view-creating functions.

% ========================================================================
\section{ConstMatrixStructureView}
A \textit{ConstMatrixStructureView} fulfills the same requirements as \textit{ConstMatrixStructureView}, but it may not be used in GraphBLAS operations where it would be modified.


\emph{Matrix}, \emph{ConstMatrix}, and \emph{MatrixView} objects are all valid \emph{ConstMatrixView} objects.

% ========================================================================
\section{VectorView}

An object whose type fulfills the \textit{VectorView} requirement is (loosely) a 
reference to an opaque \textit{GraphBLAS Container} that has one dimension and a 
number of stored elements.  A \textit{GraphBLAS Container} is an object used to store
other objects, \textit{GraphBLAS Scalars}, that takes care of the management of the
memory used by these objects. \scott{Wording from C++ Container named requirements.}

\scott{Should the VectorView only define enough interface to perform any runtime API error checks?}

\scott{Should VectorView provide a reference to the internal container?  This is an implementation specific mechanism that does not need to be specified.}

\paragraph{Types}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Name} & \textbf{Type} & \textbf{Notes}\\
\hline
\texttt{value\_type} & \texttt{ScalarT}  & The type of objects stored in the container.\\ \hline
\texttt{index\_type} & \texttt{IndexT}   & Used to reference locations in the container \\ \hline
\texttt{size\_type}  & ??                & Can hold the number of elements stored in the container.
\end{tabularx}

\paragraph{Methods and operators}

\begin{tabularx}{\textwidth}{l l X}
\textbf{Expression} & \textbf{Return Type} & \textbf{Requirements}\\
\hline
\texttt{size()} & \texttt{index\_type}  & The size of the dimension of the vector.\\ \hline
\texttt{nvals()} & \texttt{size\_type}  & The number of elements stored in the vector. \scott{this is not required}\\ \hline
constructors? & & \\
\end{tabularx}

A \emph{Vector} object is a valid \emph{VectorView} object

% ========================================================================
\section{ConstVectorView}

Is the same as a \textit{VectorView} except that the underlying opaque container within cannot be
mutated by calls to GraphBLAS operations.  A \emph{Vector}, \emph{ConstVector} or 
\emph{VectorView} object is a valid \emph{ConstVectorView} objects.

% ========================================================================
\section{Hints}

Talk about Hint and combiner here or somewhere else?
