\chapter{Objects}
\label{Chp:Objects}


% ========================================================================
\section{Operators}

\scott{All callable objects must be supported, including <functional> and lambdas.}

% ========================================================================
\section{Monoids}

Do we define the concept of a Monoid here.  We don't "new" them, rather they
are passed as templated arguments to the backend implementation.


\scott{Likely only structs, with operator() + identity()? Do we support result\_type?}


% ========================================================================
\section{Semirings}

Do we define the concept of a Semiring here.  We don't "new" them, rather they
are passed as templated arguments to the backend implementation.


\scott{likely only structs with add90, mult(), and zero().  Do we support 
first/second\_argument\_type and result\_type?}

% ========================================================================
\section{Sequences}
\label{Sec:Sequences}

{\sf GrB\_ALL} (AllIndices class in GBTL) is an example of a compact sequence.

There should be other sequences that replace "arrays of indices" that can also be substituted.

This is also important for distributed implementations where enumerating all indices in a range can be too large.

% ========================================================================
\section{{\sf GrB\_NULL} for Mask and Accumulator}
\label{Sec:NoMaskNoAccum}

Do we want a single {\sf GrB\_NULL} type that can be passed as the mask or accumulator 
to indicate "no mask" and "no accumulate", respectively.  GBTL currently has two
different empty classes N={\sf NoMask} and {\sf NoAccumulate}

% ========================================================================
\section{Vectors}
\label{Sec:Vectors}

\scott{Add a discussion of template parameters}
Template arguments:
\begin{itemize}[leftmargin=1.1in]
\item[ScalarT]  the scalar/value/domain type stored as values in the vector (i.e. the domain)
\item[IndexT]   the unsigned integer type used to specify a location in the vector.
\item[...TagsT] variadic (variable number of type params) to be unpacked by the implementation.
Implementation "hints" or "suggestions" like sparse vs dense.
\end{itemize}

% ========================================================================
\section{Matrices}
\label{Sec:Matrices}

\scott{Add a discussion of template parameters}

Template arguments:
\begin{itemize}[leftmargin=1.1in]
\item[ScalarT]  the scalar/value/domain type stored as values in the vector (i.e. the domain)
\item[IndexT]   the unsigned integer type used to specify a location in the vector.
\item[...TagsT] variadic (variable number of type params) to be unpacked by the implementation.
Implementation "hints" or "suggestions" like sparse vs dense.
\end{itemize}

% ========================================================================
\section{Masks}
\label{Sec:Masks}

Do we support void Scalar type for matrices and vectors?

% ========================================================================
\section{Descriptors}
\label{Sec:Descriptors}

\scott{There will be no descriptors...so let it be written...so let it be done.}
